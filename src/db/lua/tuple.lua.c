const char tuple_lua[] =
"-- tuple.lua (internal file)\n"
"\n"
"local ffi = require('ffi')\n"
"local yaml = require('yaml')\n"
"local msgpackffi = require('msgpackffi')\n"
"local fun = require('fun')\n"
"local internal = require('db.internal')\n"
"\n"
"ffi.cdef([[\n"
"struct tuple\n"
"{\n"
"    uint32_t _version;\n"
"    uint16_t _refs;\n"
"    uint16_t _format_id;\n"
"    uint32_t _bsize;\n"
"    char data[0];\n"
"} __attribute__((packed));\n"
"\n"
"void\n"
"tuple_unref(struct tuple *tuple);\n"
"uint32_t\n"
"tuple_field_count(const struct tuple *tuple);\n"
"const char *\n"
"tuple_field(const struct tuple *tuple, uint32_t i);\n"
"\n"
"struct tuple_iterator {\n"
"    const struct tuple *tuple;\n"
"    const char *pos;\n"
"    int fieldno;\n"
"};\n"
"\n"
"void\n"
"tuple_rewind(struct tuple_iterator *it, const struct tuple *tuple);\n"
"\n"
"const char *\n"
"tuple_seek(struct tuple_iterator *it, uint32_t field_no);\n"
"\n"
"const char *\n"
"tuple_next(struct tuple_iterator *it);\n"
"\n"
"void\n"
"tuple_to_buf(struct tuple *tuple, char *buf);\n"
"\n"
"struct tuple *\n"
"dbffi_tuple_update(struct tuple *tuple, const char *expr, const char *expr_end);\n"
"]])\n"
"\n"
"local builtin = ffi.C\n"
"\n"
"local const_struct_tuple_ref_t = ffi.typeof('const struct tuple&')\n"
"\n"
"local tuple_gc = function(tuple)\n"
"    builtin.tuple_unref(tuple)\n"
"end\n"
"\n"
"local tuple_bless = function(tuple)\n"
"    -- must never fail:\n"
"    return ffi.gc(ffi.cast(const_struct_tuple_ref_t, tuple), tuple_gc)\n"
"end\n"
"\n"
"local tuple_iterator_t = ffi.typeof('struct tuple_iterator')\n"
"\n"
"local function tuple_iterator_next(it, tuple, pos)\n"
"    if pos == nil then\n"
"        pos = 0\n"
"    elseif type(pos) ~= \"number\" then\n"
"         error(\"error: invalid key to 'next'\")\n"
"    end\n"
"    local field\n"
"    if it.tuple == tuple and it.fieldno == pos then\n"
"        -- Sequential iteration\n"
"        field = builtin.tuple_next(it)\n"
"    else\n"
"        -- Seek\n"
"        builtin.tuple_rewind(it, tuple)\n"
"        field = builtin.tuple_seek(it, pos);\n"
"    end\n"
"    if field == nil then\n"
"        if #tuple == pos then\n"
"            -- No more fields, stop iteration\n"
"            return nil\n"
"        else\n"
"            -- Invalid pos\n"
"            error(\"error: invalid key to 'next'\")\n"
"        end\n"
"    end\n"
"    -- () used to shrink the return stack to one value\n"
"    return it.fieldno, (msgpackffi.decode_unchecked(field))\n"
"end;\n"
"\n"
"-- precreated iterator for tuple_next\n"
"local next_it = ffi.new(tuple_iterator_t)\n"
"\n"
"-- See http://www.lua.org/manual/5.2/manual.html#pdf-next\n"
"local function tuple_next(tuple, pos)\n"
"    return tuple_iterator_next(next_it, tuple, pos);\n"
"end\n"
"\n"
"-- See http://www.lua.org/manual/5.2/manual.html#pdf-ipairs\n"
"local function tuple_ipairs(tuple, pos)\n"
"    local it = ffi.new(tuple_iterator_t)\n"
"    return fun.wrap(it, tuple, pos)\n"
"end\n"
"\n"
"local function tuple_totable(tuple, i, j)\n"
"    -- use a precreated iterator for tuple_next\n"
"    builtin.tuple_rewind(next_it, tuple)\n"
"    local field\n"
"    if i ~= nil then\n"
"        if i < 1 then\n"
"            error('tuple.totable: invalid second argument')\n"
"        end\n"
"        field = builtin.tuple_seek(next_it, i - 1)\n"
"    else\n"
"        i = 1\n"
"        field = builtin.tuple_next(next_it)\n"
"    end\n"
"    if j ~= nil then\n"
"        if j <= 0 then\n"
"            error('tuple.totable: invalid third argument')\n"
"        end\n"
"    else\n"
"        j = 4294967295\n"
"    end\n"
"    local ret = {}\n"
"    while field ~= nil and i <= j do\n"
"        local val = msgpackffi.decode_unchecked(field)\n"
"        table.insert(ret, val)\n"
"        i = i + 1\n"
"        field = builtin.tuple_next(next_it)\n"
"    end\n"
"    return setmetatable(ret, msgpackffi.array_mt)\n"
"end\n"
"\n"
"local function tuple_unpack(tuple, i, j)\n"
"    return unpack(tuple_totable(tuple, i, j))\n"
"end\n"
"\n"
"local function tuple_find(tuple, offset, val)\n"
"    if val == nil then\n"
"        val = offset\n"
"        offset = 0\n"
"    end\n"
"    local r = tuple:pairs(offset):index(val)\n"
"    return r ~= nil and offset + r or nil\n"
"end\n"
"\n"
"local function tuple_findall(tuple, offset, val)\n"
"    if val == nil then\n"
"        val = offset\n"
"        offset = 0\n"
"    end\n"
"    return tuple:pairs(offset):indexes(val)\n"
"        :map(function(i) return offset + i end)\n"
"        :totable()\n"
"end\n"
"\n"
"local function tuple_update(tuple, expr)\n"
"    if type(expr) ~= 'table' then\n"
"        error(\"Usage: tuple:update({ { op, field, arg}+ })\")\n"
"    end\n"
"    local pexpr, pexpr_end = msgpackffi.encode_tuple(expr)\n"
"    local tuple = builtin.dbffi_tuple_update(tuple, pexpr, pexpr_end)\n"
"    if tuple == NULL then\n"
"        return db.error()\n"
"    end\n"
"    return tuple_bless(tuple)\n"
"end\n"
"\n"
"-- Set encode hooks for msgpackffi\n"
"local function tuple_to_msgpack(buf, tuple)\n"
"    buf:reserve(tuple._bsize)\n"
"    builtin.tuple_to_buf(tuple, buf.p)\n"
"    buf.p = buf.p + tuple._bsize\n"
"end\n"
"\n"
"msgpackffi.on_encode(ffi.typeof('const struct tuple &'), tuple_to_msgpack)\n"
"\n"
"\n"
"-- cfuncs table is set by C part\n"
"\n"
"local methods = {\n"
"    [\"next\"]        = tuple_next;\n"
"    [\"ipairs\"]      = tuple_ipairs;\n"
"    [\"pairs\"]       = tuple_ipairs; -- just alias for ipairs()\n"
"    [\"slice\"]       = cfuncs.slice;\n"
"    [\"transform\"]   = cfuncs.transform;\n"
"    [\"find\"]        = tuple_find;\n"
"    [\"findall\"]     = tuple_findall;\n"
"    [\"unpack\"]      = tuple_unpack;\n"
"    [\"totable\"]     = tuple_totable;\n"
"    [\"update\"]      = tuple_update;\n"
"    [\"bsize\"]       = function(tuple)\n"
"        return tonumber(tuple._bsize)\n"
"    end;\n"
"    [\"__serialize\"] = tuple_totable; -- encode hook for msgpack/yaml/json\n"
"}\n"
"\n"
"local tuple_field = function(tuple, field_n)\n"
"    local field = builtin.tuple_field(tuple, field_n - 1)\n"
"    if field == nil then\n"
"        return nil\n"
"    end\n"
"    -- Use () to shrink stack to the first return value\n"
"    return (msgpackffi.decode_unchecked(field))\n"
"end\n"
"\n"
"\n"
"ffi.metatype('struct tuple', {\n"
"    __len = function(tuple)\n"
"        return builtin.tuple_field_count(tuple)\n"
"    end;\n"
"    __tostring = function(tuple)\n"
"        -- Unpack tuple, call yaml.encode, remove yaml header and footer\n"
"        -- 5 = '---\\n\\n' (header), -6 = '\\n...\\n' (footer)\n"
"        return yaml.encode(methods.totable(tuple)):sub(5, -6)\n"
"    end;\n"
"    __index = function(tuple, key)\n"
"        if type(key) == \"number\" then\n"
"            return tuple_field(tuple, key)\n"
"        end\n"
"        return methods[key]\n"
"    end;\n"
"    __eq = function(tuple_a, tuple_b)\n"
"        -- Two tuple are considered equal if they have same memory address\n"
"        return ffi.cast('void *', tuple_a) == ffi.cast('void *', tuple_b);\n"
"    end;\n"
"    __pairs = tuple_ipairs;  -- Lua 5.2 compatibility\n"
"    __ipairs = tuple_ipairs; -- Lua 5.2 compatibility\n"
"})\n"
"\n"
"ffi.metatype(tuple_iterator_t, {\n"
"    __call = tuple_iterator_next;\n"
"    __tostring = function(it) return \"<tuple iterator>\" end;\n"
"})\n"
"\n"
"-- Remove the global variable\n"
"cfuncs = nil\n"
"\n"
"-- internal api for db.select and iterators\n"
"db.tuple.bless = tuple_bless\n"
""
;
