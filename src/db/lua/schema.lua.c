const char schema_lua[] =
"-- schema.lua (internal file)\n"
"--\n"
"local ffi = require('ffi')\n"
"local msgpackffi = require('msgpackffi')\n"
"local fun = require('fun')\n"
"local session = db.session\n"
"local internal = require('db.internal')\n"
"\n"
"local builtin = ffi.C\n"
"\n"
"ffi.cdef[[\n"
"    struct space *space_by_id(uint32_t id);\n"
"    void space_run_triggers(struct space *space, bool yesno);\n"
"\n"
"    struct iterator {\n"
"        struct tuple *(*next)(struct iterator *);\n"
"        void (*free)(struct iterator *);\n"
"        void (*close)(struct iterator *);\n"
"        int sc_version;\n"
"        uint32_t space_id;\n"
"        uint32_t index_id;\n"
"    };\n"
"    size_t\n"
"    dbffi_index_len(uint32_t space_id, uint32_t index_id);\n"
"    size_t\n"
"    dbffi_index_bsize(uint32_t space_id, uint32_t index_id);\n"
"    struct tuple *\n"
"    dbffi_index_random(uint32_t space_id, uint32_t index_id, uint32_t rnd);\n"
"    struct tuple *\n"
"    dbffi_index_get(uint32_t space_id, uint32_t index_id, const char *key);\n"
"    struct tuple *\n"
"    dbffi_index_min(uint32_t space_id, uint32_t index_id, const char *key);\n"
"    struct tuple *\n"
"    dbffi_index_max(uint32_t space_id, uint32_t index_id, const char *key);\n"
"    ssize_t\n"
"    dbffi_index_count(uint32_t space_id, uint32_t index_id, int type,\n"
"                       const char *key);\n"
"    struct iterator *\n"
"    dbffi_index_iterator(uint32_t space_id, uint32_t index_id, int type,\n"
"                  const char *key);\n"
"    struct tuple *\n"
"    dbffi_iterator_next(struct iterator *itr);\n"
"\n"
"    struct port;\n"
"    struct port_ffi\n"
"    {\n"
"        struct port_vtab *vtab;\n"
"        uint32_t size;\n"
"        uint32_t capacity;\n"
"        struct tuple **ret;\n"
"    };\n"
"\n"
"    void\n"
"    port_ffi_create(struct port_ffi *port);\n"
"    void\n"
"    port_ffi_destroy(struct port_ffi *port);\n"
"\n"
"    int\n"
"    dbffi_select(struct port_ffi *port, uint32_t space_id, uint32_t index_id,\n"
"              int iterator, uint32_t offset, uint32_t limit,\n"
"              const char *key, const char *key_end);\n"
"    void password_prepare(const char *password, int len,\n"
"\t\t                  char *out, int out_len);\n"
"    int\n"
"    dbffi_txn_begin();\n"
"\n"
"    void\n"
"    dbffi_txn_rollback();\n"
"]]\n"
"\n"
"local function user_or_role_resolve(user)\n"
"    local _user = db.space[db.schema.USER_ID]\n"
"    local tuple\n"
"    if type(user) == 'string' then\n"
"        tuple = _user.index.name:get{user}\n"
"    else\n"
"        tuple = _user:get{user}\n"
"    end\n"
"    if tuple == nil then\n"
"        return nil\n"
"    end\n"
"    return tuple[1]\n"
"end\n"
"\n"
"local function role_resolve(name_or_id)\n"
"    local _user = db.space[db.schema.USER_ID]\n"
"    local tuple\n"
"    if type(name_or_id) == 'string' then\n"
"        tuple = _user.index.name:get{name_or_id}\n"
"    elseif type(name_or_id) ~= 'nil' then\n"
"        tuple = _user:get{name_or_id}\n"
"    end\n"
"    if tuple == nil or tuple[4] ~= 'role' then\n"
"        return nil\n"
"    else\n"
"        return tuple[1]\n"
"    end\n"
"end\n"
"\n"
"local function user_resolve(name_or_id)\n"
"    local _user = db.space[db.schema.USER_ID]\n"
"    local tuple\n"
"    if type(name_or_id) == 'string' then\n"
"        tuple = _user.index.name:get{name_or_id}\n"
"    elseif type(name_or_id) ~= 'nil' then\n"
"        tuple = _user:get{name_or_id}\n"
"    end\n"
"    if tuple == nil or tuple[4] ~= 'user' then\n"
"        return nil\n"
"    else\n"
"        return tuple[1]\n"
"    end\n"
"end\n"
"\n"
"--[[\n"
" @brief Common function to check table with parameters (like options)\n"
" @param table - table with parameters\n"
" @param template - table with expected types of expected parameters\n"
"  type could be comma separated string with lua types (number, string etc),\n"
"  or 'any' if any type is allowed\n"
" The function checks following:\n"
" 1)that parameters table is a table (or nil)\n"
" 2)all keys in parameters are present in template\n"
" 3)type of every parameter fits (one of) types described in template\n"
" Check (2) and (3) could be disabled by adding {, dont_check = <smth is true>, }\n"
"  into parameters table\n"
" The functions calls db.error(db.error.ILLEGAL_PARAMS, ..) on error\n"
" @example\n"
" check_param_table(options, { user = 'string',\n"
"                              port = 'string, number',\n"
"                              data = 'any' } )\n"
"--]]\n"
"local function check_param_table(table, template)\n"
"    if table == nil then\n"
"        return\n"
"    end\n"
"    if type(table) ~= 'table' then\n"
"        db.error(db.error.ILLEGAL_PARAMS,\n"
"                  \"options should be a table\")\n"
"    end\n"
"    -- just pass {.. dont_check = true, ..} to disable checks below\n"
"    if table.dont_check then\n"
"        return\n"
"    end\n"
"    for k,v in pairs(table) do\n"
"        if template[k] == nil then\n"
"            db.error(db.error.ILLEGAL_PARAMS,\n"
"                      \"options parameter '\" .. k .. \"' is unexpected\")\n"
"        elseif template[k] == 'any' then\n"
"            -- any type is ok\n"
"        elseif (string.find(template[k], ',') == nil) then\n"
"            -- one type\n"
"            if type(v) ~= template[k] then\n"
"                db.error(db.error.ILLEGAL_PARAMS,\n"
"                          \"options parameter '\" .. k ..\n"
"                          \"' should be of type \" .. template[k])\n"
"            end\n"
"        else\n"
"            local good_types = string.gsub(template[k], ' ', '')\n"
"            local haystack = ',' .. good_types .. ','\n"
"            local needle = ',' .. type(v) .. ','\n"
"            if (string.find(haystack, needle) == nil) then\n"
"                good_types = string.gsub(good_types, ',', ', ')\n"
"                db.error(db.error.ILLEGAL_PARAMS,\n"
"                          \"options parameter '\" .. k ..\n"
"                          \"' should be one of types: \" .. template[k])\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"--[[\n"
" @brief Common function to check type parameter (of function)\n"
" Calls db.error(db.error.ILLEGAL_PARAMS, ) on error\n"
" @example: check_param(user, 'user', 'string')\n"
"--]]\n"
"local function check_param(param, name, should_be_type)\n"
"    if type(param) ~= should_be_type then\n"
"        db.error(db.error.ILLEGAL_PARAMS,\n"
"                  name .. \" should be a \" .. should_be_type)\n"
"    end\n"
"end\n"
"\n"
"--[[\n"
" Adds to a table key-value pairs from defaults table\n"
"  that is not present in original table.\n"
" Returns updated table.\n"
" If nil is passed instead of table, it's treated as empty table {}\n"
" For example update_param_table({ type = 'hash', temporary = true },\n"
"                                { type = 'tree', unique = true })\n"
"  will return table { type = 'hash', temporary = true, unique = true }\n"
"--]]\n"
"local function update_param_table(table, defaults)\n"
"    if table == nil then\n"
"        return defaults\n"
"    end\n"
"    if (defaults == nil) then\n"
"        return table\n"
"    end\n"
"    for k,v in pairs(defaults) do\n"
"        if table[k] == nil then\n"
"            table[k] = v\n"
"        end\n"
"    end\n"
"    return table\n"
"end\n"
"\n"
"db.begin = function()\n"
"    if ffi.C.dbffi_txn_begin() == -1 then\n"
"        db.error()\n"
"    end\n"
"end\n"
"-- db.commit yields, so it's defined in call.cc\n"
"\n"
"db.rollback = ffi.C.dbffi_txn_rollback;\n"
"\n"
"db.schema.space = {}\n"
"db.schema.space.create = function(name, options)\n"
"    check_param(name, 'name', 'string')\n"
"    local options_template = {\n"
"        if_not_exists = 'boolean',\n"
"        temporary = 'boolean',\n"
"        engine = 'string',\n"
"        id = 'number',\n"
"        field_count = 'number',\n"
"        user = 'string, number',\n"
"        format = 'table'\n"
"    }\n"
"    local options_defaults = {\n"
"        engine = 'memtx',\n"
"        field_count = 0,\n"
"    }\n"
"    check_param_table(options, options_template)\n"
"    options = update_param_table(options, options_defaults)\n"
"\n"
"    local _space = db.space[db.schema.SPACE_ID]\n"
"    if db.space[name] then\n"
"        if options.if_not_exists then\n"
"            return db.space[name], \"not created\"\n"
"        else\n"
"            db.error(db.error.SPACE_EXISTS, name)\n"
"        end\n"
"    end\n"
"    local id = options.id\n"
"    if not id then\n"
"        local _schema = db.space._schema\n"
"        local max_id = _schema:update({'max_id'}, {{'+', 2, 1}})\n"
"        if max_id == nil then\n"
"            id = _space.index.primary:max()[1]\n"
"            if id < db.schema.SYSTEM_ID_MAX then\n"
"                id = db.schema.SYSTEM_ID_MAX\n"
"            end\n"
"            max_id = _schema:insert{'max_id', id + 1}\n"
"        end\n"
"        id = max_id[2]\n"
"    end\n"
"    local uid = nil\n"
"    if options.user then\n"
"        uid = user_or_role_resolve(options.user)\n"
"    end\n"
"    if uid == nil then\n"
"        uid = session.uid()\n"
"    end\n"
"    local temporary = options.temporary and \"temporary\" or \"\"\n"
"    local format = options.format and options.format or {}\n"
"    _space:insert{id, uid, name, options.engine, options.field_count, temporary, format}\n"
"    return db.space[id], \"created\"\n"
"end\n"
"\n"
"-- space format - the metadata about space fields\n"
"function db.schema.space.format(id, format)\n"
"    _space = db.space._space\n"
"    check_param(id, 'id', 'number')\n"
"    check_param(format, 'format', 'table')\n"
"    if format == nil then\n"
"        return _space:get(id)[7]\n"
"    else\n"
"        _space:update(id, {{'=', 7, format}})\n"
"    end\n"
"end\n"
"\n"
"db.schema.create_space = db.schema.space.create\n"
"\n"
"db.schema.space.drop = function(space_id, space_name)\n"
"    check_param(space_id, 'space_id', 'number')\n"
"\n"
"    local _space = db.space[db.schema.SPACE_ID]\n"
"    local _index = db.space[db.schema.INDEX_ID]\n"
"    local _priv = db.space[db.schema.PRIV_ID]\n"
"    local keys = _index:select(space_id)\n"
"    for i = #keys, 1, -1 do\n"
"        local v = keys[i]\n"
"        _index:delete{v[1], v[2]}\n"
"    end\n"
"    local privs = _priv.index.object:select{'space', space_id}\n"
"    for k, tuple in pairs(privs) do\n"
"        db.schema.user.revoke(tuple[2], tuple[5], tuple[3], tuple[4])\n"
"    end\n"
"    if _space:delete{space_id} == nil then\n"
"        if space_name == nil then\n"
"            space_name = '#'..tostring(space_id)\n"
"        end\n"
"        db.error(db.error.NO_SUCH_SPACE, space_name)\n"
"    end\n"
"end\n"
"\n"
"db.schema.space.rename = function(space_id, space_name)\n"
"    check_param(space_id, 'space_id', 'number')\n"
"    check_param(space_name, 'space_name', 'string')\n"
"\n"
"    local _space = db.space[db.schema.SPACE_ID]\n"
"    _space:update(space_id, {{\"=\", 3, space_name}})\n"
"end\n"
"\n"
"db.schema.index = {}\n"
"\n"
"local function check_index_parts(parts)\n"
"    if type(parts) ~= \"table\" then\n"
"        db.error(db.error.ILLEGAL_PARAMS,\n"
"                  \"options.parts parameter should be a table\")\n"
"    end\n"
"    if #parts % 2 ~= 0 then\n"
"        db.error(db.error.ILLEGAL_PARAMS,\n"
"                  \"options.parts: expected filed_no (number), type (string) pairs\")\n"
"    end\n"
"    for i=1,#parts,2 do\n"
"        if type(parts[i]) ~= \"number\" then\n"
"            db.error(db.error.ILLEGAL_PARAMS,\n"
"                      \"options.parts: expected filed_no (number), type (string) pairs\")\n"
"        elseif parts[i] == 0 then\n"
"            -- Lua uses one-based field numbers but _space is zero-based\n"
"            db.error(db.error.ILLEGAL_PARAMS,\n"
"                      \"invalid index parts: field_no must be one-based\")\n"
"        end\n"
"    end\n"
"    for i=2,#parts,2 do\n"
"        if type(parts[i]) ~= \"string\" then\n"
"            db.error(db.error.ILLEGAL_PARAMS,\n"
"                      \"options.parts: expected filed_no (number), type (string) pairs\")\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function update_index_parts(parts)\n"
"    for i=1,#parts,2 do\n"
"        -- Lua uses one-based field numbers but _space is zero-based\n"
"        parts[i] = parts[i] - 1\n"
"    end\n"
"    return parts\n"
"end\n"
"\n"
"db.schema.index.create = function(space_id, name, options)\n"
"    check_param(space_id, 'space_id', 'number')\n"
"    check_param(name, 'name', 'string')\n"
"    local options_template = {\n"
"        type = 'string',\n"
"        parts = 'table',\n"
"        unique = 'boolean',\n"
"        id = 'number',\n"
"        if_not_exists = 'boolean',\n"
"    }\n"
"    local options_defaults = {\n"
"        type = 'tree',\n"
"        parts = { 1, \"num\" },\n"
"        unique = true,\n"
"    }\n"
"    check_param_table(options, options_template)\n"
"    options = update_param_table(options, options_defaults)\n"
"    check_index_parts(options.parts)\n"
"    options.parts = update_index_parts(options.parts)\n"
"\n"
"    local _index = db.space[db.schema.INDEX_ID]\n"
"    if _index.index.name:get{space_id, name} then\n"
"        if options.if_not_exists then\n"
"            return db.space[space_id].index[name], \"not created\"\n"
"        else\n"
"            db.error(db.error.INDEX_EXISTS, name)\n"
"        end\n"
"    end\n"
"\n"
"    local unique = options.unique and 1 or 0\n"
"    local part_count = bit.rshift(#options.parts, 1)\n"
"    local parts = options.parts\n"
"    local iid = 0\n"
"    -- max\n"
"    local tuple = _index.index[0]\n"
"        :select(space_id, { limit = 1, iterator = 'LE' })[1]\n"
"    if tuple then\n"
"        local id = tuple[1]\n"
"        if id == space_id then\n"
"            iid = tuple[2] + 1\n"
"        end\n"
"    end\n"
"    if options.id then\n"
"        iid = options.id\n"
"    end\n"
"    _index:insert{space_id, iid, name, options.type,\n"
"                  unique, part_count, unpack(options.parts)}\n"
"    return db.space[space_id].index[name]\n"
"end\n"
"\n"
"db.schema.index.drop = function(space_id, index_id)\n"
"    check_param(space_id, 'space_id', 'number')\n"
"    check_param(index_id, 'index_id', 'number')\n"
"\n"
"    local _index = db.space[db.schema.INDEX_ID]\n"
"    _index:delete{space_id, index_id}\n"
"end\n"
"\n"
"db.schema.index.rename = function(space_id, index_id, name)\n"
"    check_param(space_id, 'space_id', 'number')\n"
"    check_param(index_id, 'index_id', 'number')\n"
"    check_param(name, 'name', 'string')\n"
"\n"
"    local _index = db.space[db.schema.INDEX_ID]\n"
"    _index:update({space_id, index_id}, {{\"=\", 3, name}})\n"
"end\n"
"\n"
"db.schema.index.alter = function(space_id, index_id, options)\n"
"    if db.space[space_id] == nil then\n"
"        db.error(db.error.NO_SUCH_SPACE, '#'..tostring(space_id))\n"
"    end\n"
"    if db.space[space_id].index[index_id] == nil then\n"
"        db.error(db.error.NO_SUCH_INDEX, index_id, db.space[space_id].name)\n"
"    end\n"
"    if options == nil then\n"
"        return\n"
"    end\n"
"\n"
"    local options_template = {\n"
"        type = 'string',\n"
"        name = 'string',\n"
"        parts = 'table',\n"
"        unique = 'boolean',\n"
"        id = 'number',\n"
"    }\n"
"    check_param_table(options, options_template)\n"
"\n"
"    if type(space_id) ~= \"number\" then\n"
"        space_id = db.space[space_id].id\n"
"    end\n"
"    if type(index_id) ~= \"number\" then\n"
"        index_id = db.space[space_id].index[index_id].id\n"
"    end\n"
"    local _index = db.space[db.schema.INDEX_ID]\n"
"    if options.unique ~= nil then\n"
"        options.unique = options.unique and 1 or 0\n"
"    end\n"
"    if options.id ~= nil then\n"
"        if options.parts ~= nil then\n"
"            db.error(db.error.PROC_LUA,\n"
"                      \"Don't know how to update both id and parts\")\n"
"        end\n"
"        ops = {}\n"
"        local function add_op(value, field_no)\n"
"            if value then\n"
"                table.insert(ops, {'=', field_no, value})\n"
"            end\n"
"        end\n"
"        add_op(options.id, 2)\n"
"        add_op(options.name, 3)\n"
"        add_op(options.type, 4)\n"
"        add_op(options.unique, 5)\n"
"        _index:update({space_id, index_id}, ops)\n"
"        return\n"
"    end\n"
"    local tuple = _index:get{space_id, index_id}\n"
"    if options.name == nil then\n"
"        options.name = tuple[3]\n"
"    end\n"
"    if options.type == nil then\n"
"        options.type = tuple[4]\n"
"    end\n"
"    if options.unique == nil then\n"
"        options.unique = tuple[5]\n"
"    end\n"
"    if options.parts == nil then\n"
"        options.parts = {tuple:slice(6)} -- not part count\n"
"    else\n"
"        check_index_parts(options.parts)\n"
"        options.parts = update_index_parts(options.parts)\n"
"    end\n"
"    _index:replace{space_id, index_id, options.name, options.type,\n"
"                   options.unique, #options.parts/2, unpack(options.parts)}\n"
"end\n"
"\n"
"local function keify(key)\n"
"    if key == nil then\n"
"        return {}\n"
"    end\n"
"    if type(key) == \"table\" then\n"
"        return key\n"
"    end\n"
"    return {key}\n"
"end\n"
"\n"
"local iterator_t = ffi.typeof('struct iterator')\n"
"ffi.metatype(iterator_t, {\n"
"    __tostring = function(iterator)\n"
"        return \"<iterator state>\"\n"
"    end;\n"
"})\n"
"\n"
"local iterator_gen = function(param, state)\n"
"    --[[\n"
"        index:pairs() mostly confirms to the Lua for-in loop conventions and\n"
"        tries to follow the best practices of Lua community.\n"
"\n"
"        - this generating function is stateless.\n"
"\n"
"        - *param* should contain **immutable** data needed to fully define\n"
"          an iterator. *param* is opaque for users. Currently it contains keybuf\n"
"          string just to prevent GC from collecting it. In future some other\n"
"          variables like space_id, index_id, sc_version will be stored here.\n"
"\n"
"        - *state* should contain **immutable** transient state of an iterator.\n"
"          *state* is opaque for users. Currently it contains `struct iterator`\n"
"          cdata that is modified during iteration. This is a sad limitation of\n"
"          underlying C API. Moreover, the separation of *param* and *state* is\n"
"          not properly implemented here. These drawbacks can be fixed in\n"
"          future without changing this API.\n"
"\n"
"        Please checkout http://www.lua.org/pil/7.3.html for the further\n"
"        information.\n"
"    --]]\n"
"    if not ffi.istype(iterator_t, state) then\n"
"        error('usage gen(param, state)')\n"
"    end\n"
"    -- next() modifies state in-place\n"
"    local tuple = builtin.dbffi_iterator_next(state)\n"
"    if tuple == ffi.cast('void *', -1) then\n"
"        return db.error() -- error\n"
"    elseif tuple ~= nil then\n"
"        return state, db.tuple.bless(tuple) -- new state, value\n"
"    else\n"
"        return nil\n"
"    end\n"
"end\n"
"\n"
"local iterator_cdata_gc = function(iterator)\n"
"    return iterator.free(iterator)\n"
"end\n"
"\n"
"-- global struct port instance to use by select()/get()\n"
"local port = ffi.new('struct port_ffi')\n"
"builtin.port_ffi_create(port)\n"
"ffi.gc(port, builtin.port_ffi_destroy)\n"
"\n"
"-- Helper function for nicer error messages\n"
"-- in some cases when space object is misused\n"
"-- Takes time so should not be used for DML.\n"
"local function space_object_check(space)\n"
"        if type(space) ~= 'table' then\n"
"            space = { name = space }\n"
"        end\n"
"        local s = db.space[space.id]\n"
"        if s == nil then\n"
"            db.error(db.error.NO_SUCH_SPACE, space.name)\n"
"        end\n"
"end\n"
"\n"
"local function check_iterator_type(opts, key_is_nil)\n"
"    local itype\n"
"    if opts and opts.iterator then\n"
"        if type(opts.iterator) == \"number\" then\n"
"            itype = opts.iterator\n"
"        elseif type(opts.iterator) == \"string\" then\n"
"            itype = db.index[string.upper(opts.iterator)]\n"
"            if itype == nil then\n"
"                db.error(db.error.ITERATOR_TYPE, opts.iterator)\n"
"            end\n"
"        else\n"
"            db.error(db.error.ITERATOR_TYPE, tostring(opts.iterator))\n"
"        end\n"
"    else\n"
"        -- Use ALL for {} and nil keys and EQ for other keys\n"
"        itype = key_is_nil and db.index.ALL or db.index.EQ\n"
"    end\n"
"    return itype\n"
"end\n"
"\n"
"function db.schema.space.bless(space)\n"
"    local index_mt = {}\n"
"    -- __len and __index\n"
"    index_mt.len = function(index)\n"
"        local ret = builtin.dbffi_index_len(index.space_id, index.id)\n"
"        if ret == -1 then\n"
"            db.error()\n"
"        end\n"
"        return tonumber(ret)\n"
"    end\n"
"    -- index.bsize\n"
"    index_mt.bsize = function(index)\n"
"        local ret = builtin.dbffi_index_bsize(index.space_id, index.id)\n"
"        if ret == -1 then\n"
"            db.error()\n"
"        end\n"
"        return tonumber(ret)\n"
"    end\n"
"    index_mt.__len = index_mt.len -- Lua 5.2 compatibility\n"
"    index_mt.__newindex = function(table, index)\n"
"        return error('Attempt to modify a read-only table') end\n"
"    index_mt.__index = index_mt\n"
"    -- min and max\n"
"    index_mt.min = function(index, key)\n"
"        local pkey = msgpackffi.encode_tuple(key)\n"
"        local tuple = builtin.dbffi_index_min(index.space_id, index.id, pkey)\n"
"        if tuple == ffi.cast('void *', -1) then\n"
"            db.error() -- error\n"
"        elseif tuple ~= nil then\n"
"            return db.tuple.bless(tuple)\n"
"        else\n"
"            return\n"
"        end\n"
"    end\n"
"    index_mt.max = function(index, key)\n"
"        local pkey = msgpackffi.encode_tuple(key)\n"
"        local tuple = builtin.dbffi_index_max(index.space_id, index.id, pkey)\n"
"        if tuple == ffi.cast('void *', -1) then\n"
"            db.error() -- error\n"
"        elseif tuple ~= nil then\n"
"            return db.tuple.bless(tuple)\n"
"        else\n"
"            return\n"
"        end\n"
"    end\n"
"    index_mt.random = function(index, rnd)\n"
"        rnd = rnd or math.random()\n"
"        local tuple = builtin.dbffi_index_random(index.space_id, index.id, rnd)\n"
"        if tuple == ffi.cast('void *', -1) then\n"
"            db.error() -- error\n"
"        elseif tuple ~= nil then\n"
"            return db.tuple.bless(tuple)\n"
"        else\n"
"            return\n"
"        end\n"
"    end\n"
"    -- iteration\n"
"    index_mt.pairs = function(index, key, opts)\n"
"        local pkey, pkey_end = msgpackffi.encode_tuple(key)\n"
"        local itype = check_iterator_type(opts, pkey + 1 >= pkey_end);\n"
"\n"
"        local keybuf = ffi.string(pkey, pkey_end - pkey)\n"
"        local cdata = builtin.dbffi_index_iterator(index.space_id, index.id,\n"
"            itype, keybuf);\n"
"        if cdata == nil then\n"
"            db.error()\n"
"        end\n"
"\n"
"        return fun.wrap(iterator_gen, keybuf, ffi.gc(cdata, iterator_cdata_gc))\n"
"    end\n"
"    index_mt.__pairs = index_mt.pairs -- Lua 5.2 compatibility\n"
"    index_mt.__ipairs = index_mt.pairs -- Lua 5.2 compatibility\n"
"    -- index subtree size\n"
"    index_mt.count = function(index, key, opts)\n"
"        local pkey, pkey_end = msgpackffi.encode_tuple(key)\n"
"        local itype = check_iterator_type(opts, pkey + 1 >= pkey_end);\n"
"        local count = builtin.dbffi_index_count(index.space_id, index.id,\n"
"            itype, pkey);\n"
"        if count == -1 then\n"
"            db.error()\n"
"        end\n"
"        return tonumber(count)\n"
"    end\n"
"\n"
"    local function check_index(space, index_id)\n"
"        if space.index[index_id] == nil then\n"
"            db.error(db.error.NO_SUCH_INDEX, index_id, space.name)\n"
"        end\n"
"    end\n"
"\n"
"    index_mt.get = function(index, key)\n"
"        local key, key_end = msgpackffi.encode_tuple(key)\n"
"        local tuple = builtin.dbffi_index_get(index.space_id, index.id, key)\n"
"        if tuple == ffi.cast('void *', -1) then\n"
"            return db.error() -- error\n"
"        elseif tuple ~= nil then\n"
"            return db.tuple.bless(tuple)\n"
"        else\n"
"            return\n"
"        end\n"
"    end\n"
"\n"
"    index_mt.select = function(index, key, opts)\n"
"        local offset = 0\n"
"        local limit = 4294967295\n"
"        local iterator = db.index.EQ\n"
"\n"
"        local key, key_end = msgpackffi.encode_tuple(key)\n"
"        if key_end == key + 1 then -- empty array\n"
"            iterator = db.index.ALL\n"
"        end\n"
"\n"
"        if opts ~= nil then\n"
"            if opts.offset ~= nil then\n"
"                offset = opts.offset\n"
"            end\n"
"            if type(opts.iterator) == \"string\" then\n"
"                local resolved_iter = db.index[string.upper(opts.iterator)]\n"
"                if resolved_iter == nil then\n"
"                    db.error(db.error.ITERATOR_TYPE, opts.iterator);\n"
"                end\n"
"                opts.iterator = resolved_iter\n"
"            end\n"
"            if opts.iterator ~= nil then\n"
"                iterator = opts.iterator\n"
"            end\n"
"            if opts.limit ~= nil then\n"
"                limit = opts.limit\n"
"            end\n"
"        end\n"
"\n"
"        if builtin.dbffi_select(port, index.space_id,\n"
"            index.id, iterator, offset, limit, key, key_end) ~=0 then\n"
"            return db.error()\n"
"        end\n"
"\n"
"        local ret = {}\n"
"        for i=0,port.size - 1,1 do\n"
"            -- tuple.bless must never fail\n"
"            ret[i + 1] = db.tuple.bless(port.ret[i])\n"
"        end\n"
"        return ret\n"
"    end\n"
"    index_mt.update = function(index, key, ops)\n"
"        return internal.update(index.space_id, index.id, keify(key), ops);\n"
"    end\n"
"    index_mt.delete = function(index, key)\n"
"        return internal.delete(index.space_id, index.id, keify(key));\n"
"    end\n"
"    index_mt.drop = function(index)\n"
"        return db.schema.index.drop(index.space_id, index.id)\n"
"    end\n"
"    index_mt.rename = function(index, name)\n"
"        return db.schema.index.rename(index.space_id, index.id, name)\n"
"    end\n"
"    index_mt.alter= function(index, options)\n"
"        if index.id == nil or index.space_id == nil then\n"
"            db.error(db.error.PROC_LUA, \"Usage: index:alter{opts}\")\n"
"        end\n"
"        return db.schema.index.alter(index.space_id, index.id, options)\n"
"    end\n"
"    --\n"
"    local space_mt = {}\n"
"    space_mt.len = function(space)\n"
"        if space.index[0] == nil then\n"
"            return 0 -- empty space without indexes, return 0\n"
"        end\n"
"        return space.index[0]:len()\n"
"    end\n"
"    space_mt.__newindex = index_mt.__newindex\n"
"\n"
"    space_mt.get = function(space, key)\n"
"        check_index(space, 0)\n"
"        return space.index[0]:get(key)\n"
"    end\n"
"    space_mt.select = function(space, key, opts)\n"
"        check_index(space, 0)\n"
"        return space.index[0]:select(key, opts)\n"
"    end\n"
"    space_mt.insert = function(space, tuple)\n"
"        return internal.insert(space.id, tuple);\n"
"    end\n"
"    space_mt.replace = function(space, tuple)\n"
"        return internal.replace(space.id, tuple);\n"
"    end\n"
"    space_mt.put = space_mt.replace; -- put is an alias for replace\n"
"    space_mt.update = function(space, key, ops)\n"
"        check_index(space, 0)\n"
"        return space.index[0]:update(key, ops)\n"
"    end\n"
"    space_mt.delete = function(space, key)\n"
"        check_index(space, 0)\n"
"        return space.index[0]:delete(key)\n"
"    end\n"
"-- Assumes that spaceno has a TREE (NUM) primary key\n"
"-- inserts a tuple after getting the next value of the\n"
"-- primary key and returns it back to the user\n"
"    space_mt.auto_increment = function(space, tuple)\n"
"        local max_tuple = space.index[0]:max()\n"
"        local max = 0\n"
"        if max_tuple ~= nil then\n"
"            max = max_tuple[1]\n"
"        end\n"
"        table.insert(tuple, 1, max + 1)\n"
"        return space:insert(tuple)\n"
"    end\n"
"\n"
"    --\n"
"    -- Increment counter identified by primary key.\n"
"    -- Create counter if not exists.\n"
"    -- Returns updated value of the counter.\n"
"    --\n"
"    space_mt.inc = function(space, key)\n"
"        local key = keify(key)\n"
"        local cnt_index = #key + 1\n"
"        local tuple\n"
"        while true do\n"
"            tuple = space:update(key, {{'+', cnt_index, 1}})\n"
"            if tuple ~= nil then break end\n"
"            local data = key\n"
"            table.insert(data, 1)\n"
"            tuple = space:insert(data)\n"
"            if tuple ~= nil then break end\n"
"        end\n"
"        return tuple[cnt_index]\n"
"    end\n"
"\n"
"    --\n"
"    -- Decrement counter identified by primary key.\n"
"    -- Delete counter if it decreased to zero.\n"
"    -- Returns updated value of the counter.\n"
"    --\n"
"    space_mt.dec = function(space, key)\n"
"        local key = keify(key)\n"
"        local cnt_index = #key + 1\n"
"        local tuple = space:get(key)\n"
"        if tuple == nil then return 0 end\n"
"        if tuple[cnt_index] == 1 then\n"
"            space:delete(key)\n"
"            return 0\n"
"        else\n"
"            tuple = space:update(key, {{'-', cnt_index, 1}})\n"
"            return tuple[cnt_index]\n"
"        end\n"
"    end\n"
"\n"
"    space_mt.pairs = function(space, key)\n"
"        if space.index[0] == nil then\n"
"            -- empty space without indexes, return empty iterator\n"
"            return fun.iter({})\n"
"        end\n"
"        check_index(space, 0)\n"
"        return space.index[0]:pairs(key)\n"
"    end\n"
"    space_mt.__pairs = space_mt.pairs -- Lua 5.2 compatibility\n"
"    space_mt.__ipairs = space_mt.pairs -- Lua 5.2 compatibility\n"
"    space_mt.truncate = function(space)\n"
"        if space.index[0] == nil then\n"
"            return -- empty space without indexes, nothing to truncate\n"
"        end\n"
"        local _index = db.space[db.schema.INDEX_ID]\n"
"        -- drop and create all indexes\n"
"        local keys = _index:select(space.id)\n"
"        for i = #keys, 1, -1 do\n"
"            local v = keys[i]\n"
"            _index:delete{v[1], v[2]}\n"
"        end\n"
"        for i = 1, #keys, 1 do\n"
"            _index:insert(keys[i])\n"
"        end\n"
"    end\n"
"    space_mt.format = function(space, format)\n"
"        return db.schema.space.format(space.id, format)\n"
"    end\n"
"    space_mt.drop = function(space)\n"
"        return db.schema.space.drop(space.id, space.name)\n"
"    end\n"
"    space_mt.rename = function(space, name)\n"
"        space_object_check(space)\n"
"        return db.schema.space.rename(space.id, name)\n"
"    end\n"
"    space_mt.create_index = function(space, name, options)\n"
"        space_object_check(space)\n"
"        return db.schema.index.create(space.id, name, options)\n"
"    end\n"
"    space_mt.run_triggers = function(space, yesno)\n"
"        local s = ffi.C.space_by_id(space.id)\n"
"        if s == nil then\n"
"            db.error(db.error.NO_SUCH_SPACE, space.name)\n"
"        end\n"
"        ffi.C.space_run_triggers(s, yesno)\n"
"    end\n"
"    space_mt.__index = space_mt\n"
"\n"
"    setmetatable(space, space_mt)\n"
"    if type(space.index) == 'table' and space.enabled then\n"
"        for j, index in pairs(space.index) do\n"
"            if type(j) == 'number' then\n"
"                setmetatable(index, index_mt)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function privilege_resolve(privilege)\n"
"    local numeric = 0\n"
"    if type(privilege) == 'string' then\n"
"        privilege = string.lower(privilege)\n"
"        if string.find(privilege, 'read') then\n"
"            numeric = numeric + 1\n"
"        end\n"
"        if string.find(privilege, 'write') then\n"
"            numeric = numeric + 2\n"
"        end\n"
"        if string.find(privilege, 'execute') then\n"
"            numeric = numeric + 4\n"
"        end\n"
"    else\n"
"        numeric = privilege\n"
"    end\n"
"    return numeric\n"
"end\n"
"\n"
"local function privilege_name(privilege)\n"
"    local names = {}\n"
"    if bit.band(privilege, 1) ~= 0 then\n"
"        table.insert(names, \"read\")\n"
"    end\n"
"    if bit.band(privilege, 2) ~= 0 then\n"
"        table.insert(names, \"write\")\n"
"    end\n"
"    if bit.band(privilege, 4) ~= 0 then\n"
"        table.insert(names, \"execute\")\n"
"    end\n"
"    return table.concat(names, \",\")\n"
"end\n"
"\n"
"local function object_resolve(object_type, object_name)\n"
"    if object_type == 'universe' then\n"
"        return 0\n"
"    end\n"
"    if object_type == 'space' then\n"
"        local space = db.space[object_name]\n"
"        if  space == nil then\n"
"            db.error(db.error.NO_SUCH_SPACE, object_name)\n"
"        end\n"
"        return space.id\n"
"    end\n"
"    if object_type == 'function' then\n"
"        local _func = db.space[db.schema.FUNC_ID]\n"
"        local func\n"
"        if type(object_name) == 'string' then\n"
"            func = _func.index.name:get{object_name}\n"
"        else\n"
"            func = _func:get{object_name}\n"
"        end\n"
"        if func then\n"
"            return func[1]\n"
"        else\n"
"            db.error(db.error.NO_SUCH_FUNCTION, object_name)\n"
"        end\n"
"    end\n"
"    if object_type == 'role' then\n"
"        local _user = db.space[db.schema.USER_ID]\n"
"        local role\n"
"        if type(object_name) == 'string' then\n"
"            role = _user.index.name:get{object_name}\n"
"        else\n"
"            role = _user:get{object_name}\n"
"        end\n"
"        if role and role[4] == 'role' then\n"
"            return role[1]\n"
"        else\n"
"            db.error(db.error.NO_SUCH_ROLE, object_name)\n"
"        end\n"
"    end\n"
"\n"
"    db.error(db.error.UNKNOWN_SCHEMA_OBJECT, object_type)\n"
"end\n"
"\n"
"local function object_name(object_type, object_id)\n"
"    if object_type == 'universe' then\n"
"        return \"\"\n"
"    end\n"
"    local space\n"
"    if object_type == 'space' then\n"
"        space = db.space._space\n"
"    elseif object_type == 'function' then\n"
"        space = db.space._func\n"
"    elseif object_type == 'role' or object_type == 'user' then\n"
"        space = db.space._user\n"
"    else\n"
"        db.error(db.error.UNKNOWN_SCHEMA_OBJECT, object_type)\n"
"    end\n"
"    return space:get{object_id}[3]\n"
"end\n"
"\n"
"db.schema.func = {}\n"
"db.schema.func.create = function(name, opts)\n"
"    opts = opts or {}\n"
"    check_param_table(opts, { setuid = 'boolean', if_not_exists = 'boolean' })\n"
"    local _func = db.space[db.schema.FUNC_ID]\n"
"    local func = _func.index.name:get{name}\n"
"    if func then\n"
"        if not opts.if_not_exists then\n"
"            db.error(db.error.FUNCTION_EXISTS, name)\n"
"        end\n"
"        return\n"
"    end\n"
"    opts = update_param_table(opts, { setuid = false })\n"
"    opts.setuid = opts.setuid and 1 or 0\n"
"    _func:auto_increment{session.uid(), name, opts.setuid}\n"
"end\n"
"\n"
"db.schema.func.drop = function(name, opts)\n"
"    opts = opts or {}\n"
"    check_param_table(opts, { if_exists = 'boolean' })\n"
"    local _func = db.space[db.schema.FUNC_ID]\n"
"    local _priv = db.space[db.schema.PRIV_ID]\n"
"    local fid\n"
"    local tuple\n"
"    if type(name) == 'string' then\n"
"        tuple = _func.index.name:get{name}\n"
"    else\n"
"        tuple = _func:get{name}\n"
"    end\n"
"    if tuple then\n"
"        fid = tuple[1]\n"
"    end\n"
"    if fid == nil then\n"
"        if not opts.if_exists then\n"
"            db.error(db.error.NO_SUCH_FUNCTION, name)\n"
"        end\n"
"        return\n"
"    end\n"
"    local privs = _priv.index.object:select{'function', fid}\n"
"    for k, tuple in pairs(privs) do\n"
"        db.schema.user.revoke(tuple[2], tuple[5], tuple[3], tuple[4])\n"
"    end\n"
"    _func:delete{fid}\n"
"end\n"
"\n"
"function db.schema.func.exists(name_or_id)\n"
"    local _func = db.space[db.schema.FUNC_ID]\n"
"    local tuple = nil\n"
"    if type(name_or_id) == 'string' then\n"
"        tuple = _func.index.name:get{name_or_id}\n"
"    elseif type(name_or_id) == 'number' then\n"
"        tuple = _func:get{name_or_id}\n"
"    end\n"
"    return tuple ~= nil\n"
"end\n"
"\n"
"db.schema.user = {}\n"
"\n"
"db.schema.user.password = function(password)\n"
"    local BUF_SIZE = 128\n"
"    local buf = ffi.new(\"char[?]\", BUF_SIZE)\n"
"    ffi.C.password_prepare(password, #password, buf, BUF_SIZE)\n"
"    return ffi.string(buf)\n"
"end\n"
"\n"
"local function chpasswd(uid, new_password)\n"
"    local _user = db.space[db.schema.USER_ID]\n"
"    auth_mech_list = {}\n"
"    auth_mech_list[\"chap-sha1\"] = db.schema.user.password(new_password)\n"
"    _user:update({uid}, {{\"=\", 5, auth_mech_list}})\n"
"end\n"
"\n"
"db.schema.user.passwd = function(name, new_password)\n"
"    if name == nil then\n"
"        db.error(db.error.PROC_LUA, \"Usage: db.schema.user.passwd([user,] password)\")\n"
"    end\n"
"    if new_password == nil then\n"
"        -- change password for current user\n"
"        new_password = name\n"
"        db.session.su('admin', chpasswd, session.uid(), new_password)\n"
"    else\n"
"        -- change password for other user\n"
"        local uid = user_resolve(name)\n"
"        if uid == nil then\n"
"            db.error(db.error.NO_SUCH_USER, name)\n"
"        end\n"
"        return chpasswd(uid, new_password)\n"
"    end\n"
"end\n"
"\n"
"db.schema.user.create = function(name, opts)\n"
"    local uid = user_or_role_resolve(name)\n"
"    opts = opts or {}\n"
"    check_param_table(opts, { password = 'string', if_not_exists = 'boolean' })\n"
"    if uid then\n"
"        if not opts.if_not_exists then\n"
"            db.error(db.error.USER_EXISTS, name)\n"
"        end\n"
"        return\n"
"    end\n"
"    auth_mech_list = {}\n"
"    if opts.password then\n"
"        auth_mech_list[\"chap-sha1\"] = db.schema.user.password(opts.password)\n"
"    end\n"
"    local _user = db.space[db.schema.USER_ID]\n"
"    uid = _user:auto_increment{session.uid(), name, 'user', auth_mech_list}[1]\n"
"    -- grant role 'public' to the user\n"
"    db.schema.user.grant(uid, 'public')\n"
"end\n"
"\n"
"db.schema.user.exists = function(name)\n"
"    if user_resolve(name) then\n"
"        return true\n"
"    else\n"
"        return false\n"
"    end\n"
"end\n"
"\n"
"local function grant(uid, name, privilege, object_type, \n"
"                     object_name, options)\n"
"    -- From user point of view, role is the same thing\n"
"    -- as a privilege. Allow syntax grant(user, role).\n"
"    if object_name == nil and object_type == nil then\n"
"        -- sic: avoid recursion, to not bother with roles\n"
"        -- named 'execute'\n"
"        object_type = 'role'\n"
"        object_name = privilege\n"
"    end\n"
"    -- sanitize privilege type for role object type\n"
"    if object_type == 'role' then\n"
"        privilege = 'execute'\n"
"    end\n"
"\n"
"    privilege_hex = privilege_resolve(privilege)\n"
"    local oid = object_resolve(object_type, object_name)\n"
"    if options == nil then\n"
"        options = {}\n"
"    end\n"
"    if options.grantor == nil then\n"
"        options.grantor = session.uid()\n"
"    else\n"
"        options.grantor = user_or_role_resolve(options.grantor)\n"
"    end\n"
"    if options.if_not_exists == nil then\n"
"        options.if_not_exists = false\n"
"    end\n"
"    local _priv = db.space[db.schema.PRIV_ID]\n"
"    -- add the granted privilege to the current set\n"
"    local tuple = _priv:get{uid, object_type, oid}\n"
"    local old_privilege\n"
"    if tuple ~= nil then\n"
"        old_privilege = tuple[5]\n"
"    else\n"
"        old_privilege = 0\n"
"    end\n"
"    privilege_hex = bit.bor(privilege_hex, old_privilege)\n"
"    -- do not execute a replace if it does not change anything\n"
"    -- XXX bug if we decide to add a grant option: new grantor\n"
"    -- replaces the old one, old grantor is lost\n"
"    if privilege_hex ~= old_privilege then\n"
"        _priv:replace{options.grantor, uid, object_type, oid, privilege_hex}\n"
"    elseif options.if_not_exists == false then\n"
"            if object_type == 'role' then\n"
"                db.error(db.error.ROLE_GRANTED, name, object_name)\n"
"            else\n"
"                db.error(db.error.PRIV_GRANTED, name, privilege,\n"
"                          object_type, object_name)\n"
"            end\n"
"    end\n"
"end\n"
"\n"
"local function revoke(uid, name, privilege, object_type, object_name, options)\n"
"    -- From user point of view, role is the same thing\n"
"    -- as a privilege. Allow syntax revoke(user, role).\n"
"    if object_name == nil and object_type == nil then\n"
"        object_type = 'role'\n"
"        object_name = privilege\n"
"        -- revoke everything possible from role,\n"
"        -- to prevent stupid mistakes with privilege name\n"
"        privilege = 'read,write,execute'\n"
"    end\n"
"    if options == nil then\n"
"        options = {}\n"
"    end\n"
"    if options.if_exists == nil then\n"
"        options.if_exists = false\n"
"    end\n"
"    local oid = object_resolve(object_type, object_name)\n"
"    local _priv = db.space[db.schema.PRIV_ID]\n"
"    local tuple = _priv:get{uid, object_type, oid}\n"
"    if tuple == nil then\n"
"        if options.if_exists then\n"
"            return\n"
"        end\n"
"        if object_type == 'role' then\n"
"            db.error(db.error.ROLE_NOT_GRANTED, name, object_name)\n"
"        else\n"
"            db.error(db.error.PRIV_NOT_GRANTED, name, privilege,\n"
"                      object_type, object_name)\n"
"        end\n"
"    end\n"
"    privilege = privilege_resolve(privilege)\n"
"    local old_privilege = tuple[5]\n"
"    local grantor = tuple[1]\n"
"    -- sic:\n"
"    -- a user may revoke more than he/she granted\n"
"    -- (erroneous user input)\n"
"    --\n"
"    privilege = bit.band(old_privilege, bit.bnot(privilege))\n"
"    if privilege ~= 0 then\n"
"        _priv:replace{grantor, uid, object_type, oid, privilege}\n"
"    else\n"
"        _priv:delete{uid, object_type, oid}\n"
"    end\n"
"end\n"
"\n"
"local function drop(uid, opts)\n"
"    -- recursive delete of user data\n"
"    local _priv = db.space[db.schema.PRIV_ID]\n"
"    local privs = _priv.index.primary:select{uid}\n"
"    for k, tuple in pairs(privs) do\n"
"        revoke(uid, uid, tuple[5], tuple[3], tuple[4])\n"
"    end\n"
"    local spaces = db.space[db.schema.SPACE_ID].index.owner:select{uid}\n"
"    for k, tuple in pairs(spaces) do\n"
"        db.space[tuple[1]]:drop()\n"
"    end\n"
"    local funcs = db.space[db.schema.FUNC_ID].index.owner:select{uid}\n"
"    for k, tuple in pairs(funcs) do\n"
"        db.schema.func.drop(tuple[1])\n"
"    end\n"
"    -- if this is a role, revoke this role from whoever it was granted to\n"
"    grants = _priv.index.object:select{'role', uid}\n"
"    for k, tuple in pairs(grants) do\n"
"        revoke(tuple[2], tuple[2], uid)\n"
"    end\n"
"    db.space[db.schema.USER_ID]:delete{uid}\n"
"end\n"
"\n"
"db.schema.user.grant = function(user_name, ...)\n"
"    local uid = user_resolve(user_name)\n"
"    if uid == nil then\n"
"        db.error(db.error.NO_SUCH_USER, user_name)\n"
"    end\n"
"    return grant(uid, user_name, ...)\n"
"end\n"
"\n"
"db.schema.user.revoke = function(user_name, ...)\n"
"    local uid = user_resolve(user_name)\n"
"    if uid == nil then\n"
"        db.error(db.error.NO_SUCH_USER, user_name)\n"
"    end\n"
"    return revoke(uid, user_name, ...)\n"
"end\n"
"\n"
"db.schema.user.drop = function(name, opts)\n"
"    opts = opts or {}\n"
"    check_param_table(opts, { if_exists = 'boolean' })\n"
"    local uid = user_resolve(name)\n"
"    if uid == nil then\n"
"        db.error(db.error.NO_SUCH_USER, name)\n"
"    end\n"
"    return drop(uid, opts)\n"
"end\n"
"\n"
"db.schema.user.info = function(user_name)\n"
"    local uid\n"
"    if user_name == nil then\n"
"        uid = db.session.uid()\n"
"    else\n"
"        uid = user_or_role_resolve(user_name)\n"
"        if uid == nil then\n"
"            db.error(db.error.NO_SUCH_USER, user_name)\n"
"        end\n"
"    end\n"
"    local _priv = db.space._priv\n"
"    local _user = db.space._priv\n"
"    local privs = {}\n"
"    for _, v in pairs(_priv:select{uid}) do\n"
"        table.insert(privs,\n"
"                     {privilege_name(v[5]), v[3], object_name(v[3], v[4])})\n"
"    end\n"
"    return privs\n"
"end\n"
"\n"
"db.schema.role = {}\n"
"\n"
"db.schema.role.exists = function(name)\n"
"    if role_resolve(name) then\n"
"        return true\n"
"    else\n"
"        return false\n"
"    end\n"
"end\n"
"\n"
"db.schema.role.create = function(name, opts)\n"
"    opts = opts or {}\n"
"    check_param_table(opts, { if_not_exists = 'boolean' })\n"
"    local uid = user_or_role_resolve(name)\n"
"    if uid then\n"
"        if not opts.if_not_exists then\n"
"            db.error(db.error.ROLE_EXISTS, name)\n"
"        end\n"
"        return\n"
"    end\n"
"    local _user = db.space[db.schema.USER_ID]\n"
"    _user:auto_increment{session.uid(), name, 'role'}\n"
"end\n"
"\n"
"db.schema.role.drop = function(name, opts)\n"
"    opts = opts or {}\n"
"    check_param_table(opts, { if_exists = 'boolean' })\n"
"    local uid = role_resolve(name)\n"
"    if uid == nil then\n"
"        if not opts.if_exists then\n"
"            db.error(db.error.NO_SUCH_ROLE, name)\n"
"        end\n"
"        return\n"
"    end\n"
"    return drop(uid)\n"
"end\n"
"db.schema.role.grant = function(user_name, ...)\n"
"    local uid = role_resolve(user_name)\n"
"    if uid == nil then\n"
"        db.error(db.error.NO_SUCH_ROLE, user_name)\n"
"    end\n"
"    return grant(uid, user_name, ...)\n"
"end\n"
"db.schema.role.revoke = function(user_name, ...)\n"
"    local uid = role_resolve(user_name)\n"
"    if uid == nil then\n"
"        db.error(db.error.NO_SUCH_ROLE, user_name)\n"
"    end\n"
"    return revoke(uid, user_name, ...)\n"
"end\n"
"db.schema.role.info = db.schema.user.info\n"
""
;
