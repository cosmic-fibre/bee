const char snapshot_daemon_lua[] =
"-- snapshot_daemon.lua (internal file)\n"
"\n"
"do\n"
"    local log = require 'log'\n"
"    local fiber = require 'fiber'\n"
"    local fio = require 'fio'\n"
"    local yaml = require 'yaml'\n"
"    local errno = require 'errno'\n"
"\n"
"    local PREFIX = 'snapshot_daemon'\n"
"\n"
"    local daemon = {\n"
"        snapshot_period = 0;\n"
"        snapshot_count = 6;\n"
"    }\n"
"\n"
"    local function sprintf(fmt, ...) return string.format(fmt, ...) end\n"
"\n"
"    -- create snapshot, return true if no errors\n"
"    local function snapshot()\n"
"        log.info(\"making snapshot...\")\n"
"        local s, e = pcall(function() db.snapshot() end)\n"
"        if s then\n"
"            return true\n"
"        end\n"
"        -- don't complain log if snapshot is already exists\n"
"        if errno() == errno.EEXIST then\n"
"            return false\n"
"        end\n"
"        log.error(\"error while creating snapshot: %s\", e)\n"
"        return false\n"
"    end\n"
"\n"
"    -- create snapshot by several options\n"
"    local function make_snapshot(last_snap)\n"
"\n"
"        if daemon.snapshot_period == nil then\n"
"            return false\n"
"        end\n"
"\n"
"        if not(daemon.snapshot_period > 0) then\n"
"            return false\n"
"        end\n"
"\n"
"\n"
"        if last_snap == nil then\n"
"            return snapshot()\n"
"        end\n"
"\n"
"        local vclock = db.info.vclock\n"
"        local lsn = 0\n"
"        for i, vlsn in pairs(vclock) do\n"
"            lsn = lsn + vlsn\n"
"        end\n"
"\n"
"        local snap_name = sprintf('%020d.snap', tonumber(lsn))\n"
"        if fio.basename(last_snap) == snap_name then\n"
"            log.debug('snapshot file %s already exists', last_snap)\n"
"            return false\n"
"        end\n"
"\n"
"        local snstat = fio.stat(last_snap)\n"
"        if snstat == nil then\n"
"            log.error(\"can't stat %s: %s\", snaps[#snaps], errno.strerror())\n"
"            return false\n"
"        end\n"
"        if snstat.mtime <= fiber.time() + daemon.snapshot_period then\n"
"            return snapshot(snaps)\n"
"        end\n"
"    end\n"
"\n"
"    -- check filesystem and current time\n"
"    local function process(self)\n"
"        local snaps = fio.glob(fio.pathjoin(db.cfg.snap_dir, '*.snap'))\n"
"\n"
"        if snaps == nil then\n"
"            log.error(\"can't read snap_dir %s: %s\", db.cfg.snap_dir,\n"
"                      errno.strerror())\n"
"            return\n"
"        end\n"
"\n"
"        if not make_snapshot(snaps[#snaps]) then\n"
"            return\n"
"        end\n"
"\n"
"        -- cleanup code\n"
"        if daemon.snapshot_count == nil then\n"
"            return\n"
"        end\n"
"\n"
"        if not (self.snapshot_count > 0) then\n"
"            return\n"
"        end\n"
"\n"
"\n"
"        -- reload snap list after snapshot\n"
"        snaps = fio.glob(fio.pathjoin(db.cfg.snap_dir, '*.snap'))\n"
"        local xlogs = fio.glob(fio.pathjoin(db.cfg.wal_dir, '*.xlog'))\n"
"        if xlogs == nil then\n"
"            log.error(\"can't read wal_dir %s: %s\", db.cfg.wal_dir,\n"
"                      errno.strerror())\n"
"            return\n"
"        end\n"
"\n"
"        while #snaps > self.snapshot_count do\n"
"            local rm = snaps[1]\n"
"            table.remove(snaps, 1)\n"
"\n"
"            log.info(\"removing old snapshot %s\", rm)\n"
"            if not fio.unlink(rm) then\n"
"                log.error(\"error while removing %s: %s\",\n"
"                          rm, errno.strerror())\n"
"                return\n"
"            end\n"
"        end\n"
"\n"
"\n"
"        local snapno = fio.basename(snaps[1], '.snap')\n"
"\n"
"        while #xlogs > 0 do\n"
"            if #xlogs < 2 then\n"
"                break\n"
"            end\n"
"\n"
"            if fio.basename(xlogs[1], '.xlog') > snapno then\n"
"                break\n"
"            end\n"
"\n"
"            if fio.basename(xlogs[2], '.xlog') > snapno then\n"
"                break\n"
"            end\n"
"\n"
"\n"
"            local rm = xlogs[1]\n"
"            table.remove(xlogs, 1)\n"
"            log.info(\"removing old xlog %s\", rm)\n"
"\n"
"            if not fio.unlink(rm) then\n"
"                log.error(\"error while removing %s: %s\",\n"
"                          rm, errno.strerror())\n"
"                return\n"
"            end\n"
"        end\n"
"    end\n"
"\n"
"\n"
"    local function next_snap_interval(self)\n"
"        \n"
"        -- don't do anything in hot_standby mode\n"
"        if db.info.status ~= 'running' or\n"
"            self.snapshot_period == nil or\n"
"            self.snapshot_period <= 0 then\n"
"            return nil\n"
"        end\n"
"\n"
"        local interval = self.snapshot_period / 10\n"
"\n"
"        local time = fiber.time()\n"
"        local snaps = fio.glob(fio.pathjoin(db.cfg.snap_dir, '*.snap'))\n"
"        if snaps == nil or #snaps == 0 then\n"
"            return interval\n"
"        end\n"
"\n"
"        local last_snap = snaps[ #snaps ]\n"
"        local stat = fio.stat(last_snap)\n"
"\n"
"        if stat == nil then\n"
"            return interval\n"
"        end\n"
"\n"
"\n"
"        -- there is no activity in xlogs\n"
"        if self.snapshot_period * 2 + stat.mtime < time then\n"
"            return interval\n"
"        end\n"
"\n"
"        local time_left = self.snapshot_period + stat.mtime - time\n"
"        if time_left > 0 then\n"
"            return time_left\n"
"        end\n"
"\n"
"        return interval\n"
"\n"
"    end\n"
"\n"
"    local function daemon_fiber(self)\n"
"        fiber.name(PREFIX)\n"
"        log.info(\"started\")\n"
"        while true do\n"
"            local interval = next_snap_interval(self)\n"
"            if interval == nil then\n"
"                break\n"
"            end\n"
"            if self.control:get(interval) == nil then\n"
"                local s, e = pcall(process, self)\n"
"\n"
"                if not s then\n"
"                    log.error(e)\n"
"                end\n"
"            else\n"
"                log.info(\"reloaded\")\n"
"            end\n"
"        end\n"
"        log.info(\"stopped\")\n"
"        self.control:close()\n"
"        self.control = nil\n"
"        self.fiber = nil\n"
"    end\n"
"\n"
"    local function reload(self)\n"
"        if self.snapshot_period > 0 and self.fiber == nil then\n"
"            self.control = fiber.channel(5)\n"
"            self.fiber = fiber.create(daemon_fiber, self)\n"
"        elseif self.fiber ~= nil then\n"
"            -- wake up daemon\n"
"            self.control:put(true)\n"
"        end\n"
"    end\n"
"\n"
"    setmetatable(daemon, {\n"
"        __index = {\n"
"            set_snapshot_period = function(snapshot_period)\n"
"                daemon.snapshot_period = snapshot_period\n"
"                reload(daemon)\n"
"                return\n"
"            end,\n"
"\n"
"            set_snapshot_count = function(snapshot_count)\n"
"                if math.floor(snapshot_count) ~= snapshot_count then\n"
"                    db.error(db.error.CFG, \"snapshot_count\",\n"
"                             \"must be an integer\")\n"
"                end\n"
"                daemon.snapshot_count = snapshot_count\n"
"                reload(daemon)\n"
"           end\n"
"        }\n"
"    })\n"
"\n"
"    if db.internal == nil then\n"
"        db.internal = { [PREFIX] = daemon }\n"
"    else\n"
"        db.internal[PREFIX] = daemon\n"
"    end\n"
"end\n"
""
;
