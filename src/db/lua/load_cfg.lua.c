const char load_cfg_lua[] =
"-- load_cfg.lua - internal file\n"
"\n"
"local ffi = require('ffi')\n"
"ffi.cdef([[\n"
"void check_cfg();\n"
"void load_cfg();\n"
"void db_set_wal_mode(const char *mode);\n"
"void db_set_listen(const char *uri);\n"
"void db_set_replication_source(const char *source);\n"
"void db_set_log_level(int level);\n"
"void db_set_readahead(int readahead);\n"
"void db_set_io_collect_interval(double interval);\n"
"void db_set_too_long_threshold(double threshold);\n"
"void db_set_snap_io_rate_limit(double limit);\n"
"void db_set_panic_on_wal_error(int);\n"
"]])\n"
"\n"
"local log = require('log')\n"
"\n"
"-- see default_cfg below\n"
"local default_sham_cfg = {\n"
"    memory_limit = 0,\n"
"    threads      = 5,\n"
"    node_size    = 134217728,\n"
"    page_size    = 131072,\n"
"    compression  = \"none\"\n"
"}\n"
"\n"
"-- all available options\n"
"local default_cfg = {\n"
"    listen              = nil,\n"
"    slab_alloc_arena    = 1.7,\n"
"    slab_alloc_minimal  = 16,\n"
"    slab_alloc_maximal  = 1024 * 1024,\n"
"    slab_alloc_factor   = 1.1,\n"
"    work_dir            = nil,\n"
"    snap_dir            = \".\",\n"
"    wal_dir             = \".\",\n"
"    sham_dir          = '.',\n"
"    sham              = default_sham_cfg,\n"
"    logger              = nil,\n"
"    logger_nonblock     = true,\n"
"    log_level           = 5,\n"
"    io_collect_interval = nil,\n"
"    readahead           = 16320,\n"
"    snap_io_rate_limit  = nil, -- no limit\n"
"    too_long_threshold  = 0.5,\n"
"    wal_mode            = \"write\",\n"
"    rows_per_wal        = 500000,\n"
"    wal_dir_rescan_delay= 0.1,\n"
"    panic_on_snap_error = true,\n"
"    panic_on_wal_error  = true,\n"
"    replication_source  = nil,\n"
"    custom_proc_title   = nil,\n"
"    pid_file            = nil,\n"
"    background          = false,\n"
"    username            = nil ,\n"
"    coredump            = false,\n"
"\n"
"    -- snapshot_daemon\n"
"    snapshot_period     = 0,        -- 0 = disabled\n"
"    snapshot_count      = 6,\n"
"}\n"
"\n"
"-- see template_cfg below\n"
"local sham_template_cfg = {\n"
"    memory_limit = 'number',\n"
"    threads      = 'number',\n"
"    node_size    = 'number',\n"
"    page_size    = 'number',\n"
"    compression  = 'string'\n"
"}\n"
"\n"
"-- types of available options\n"
"-- could be comma separated lua types or 'any' if any type is allowed\n"
"local template_cfg = {\n"
"    listen              = 'string, number',\n"
"    slab_alloc_arena    = 'number',\n"
"    slab_alloc_minimal  = 'number',\n"
"    slab_alloc_maximal  = 'number',\n"
"    slab_alloc_factor   = 'number',\n"
"    work_dir            = 'string',\n"
"    snap_dir            = 'string',\n"
"    wal_dir             = 'string',\n"
"    sham_dir          = 'string',\n"
"    sham              = sham_template_cfg,\n"
"    logger              = 'string',\n"
"    logger_nonblock     = 'boolean',\n"
"    log_level           = 'number',\n"
"    io_collect_interval = 'number',\n"
"    readahead           = 'number',\n"
"    snap_io_rate_limit  = 'number',\n"
"    too_long_threshold  = 'number',\n"
"    wal_mode            = 'string',\n"
"    rows_per_wal        = 'number',\n"
"    wal_dir_rescan_delay= 'number',\n"
"    panic_on_snap_error = 'boolean',\n"
"    panic_on_wal_error  = 'boolean',\n"
"    replication_source  = 'string, number',\n"
"    custom_proc_title   = 'string',\n"
"    pid_file            = 'string',\n"
"    background          = 'boolean',\n"
"    username            = 'string',\n"
"    coredump            = 'boolean',\n"
"    snapshot_period     = 'number',\n"
"    snapshot_count      = 'number',\n"
"}\n"
"\n"
"local function normalize_uri(port)\n"
"    if port == nil or type(port) == 'table' then\n"
"        return port\n"
"    end\n"
"    return tostring(port);\n"
"end\n"
"\n"
"-- options that require special handling\n"
"local modify_cfg = {\n"
"    listen             = normalize_uri,\n"
"    replication_source = normalize_uri,\n"
"}\n"
"\n"
"-- dynamically settable options\n"
"local dynamic_cfg = {\n"
"    wal_mode                = ffi.C.db_set_wal_mode,\n"
"    listen                  = ffi.C.db_set_listen,\n"
"    replication_source      = ffi.C.db_set_replication_source,\n"
"    log_level               = ffi.C.db_set_log_level,\n"
"    io_collect_interval     = ffi.C.db_set_io_collect_interval,\n"
"    readahead               = ffi.C.db_set_readahead,\n"
"    too_long_threshold      = ffi.C.db_set_too_long_threshold,\n"
"    snap_io_rate_limit      = ffi.C.db_set_snap_io_rate_limit,\n"
"    panic_on_wal_error      = ffi.C.db_set_panic_on_wal_error,\n"
"    -- snapshot_daemon\n"
"    snapshot_period         = db.internal.snapshot_daemon.set_snapshot_period,\n"
"    snapshot_count          = db.internal.snapshot_daemon.set_snapshot_count,\n"
"    -- do nothing, affects new replicas, which query this value on start\n"
"    wal_dir_rescan_delay    = function() end\n"
"}\n"
"\n"
"local dynamic_cfg_skip_at_load = {\n"
"    wal_mode                = true,\n"
"    listen                  = true,\n"
"    replication_source      = true,\n"
"    wal_dir_rescan_delay    = true,\n"
"    panic_on_wal_error      = true,\n"
"}\n"
"\n"
"local function prepare_cfg(cfg, default_cfg, template_cfg, modify_cfg, prefix)\n"
"    if cfg == nil then\n"
"        return {}\n"
"    end\n"
"    if type(cfg) ~= 'table' then\n"
"        error(\"Error: cfg should be a table\")\n"
"    end\n"
"    -- just pass {.. dont_check = true, ..} to disable check below\n"
"    if cfg.dont_check then\n"
"        return\n"
"    end\n"
"    local readable_prefix = ''\n"
"    if prefix ~= nil and prefix ~= '' then\n"
"        readable_prefix = prefix .. '.'\n"
"    end\n"
"    local new_cfg = {}\n"
"    for k,v in pairs(cfg) do\n"
"        local readable_name = readable_prefix .. k;\n"
"        if template_cfg[k] == nil then\n"
"            error(\"Error: cfg parameter '\" .. readable_name .. \"' is unexpected\")\n"
"        elseif v == \"\" or v == nil then\n"
"            -- \"\" and NULL = ffi.cast('void *', 0) set option to default value\n"
"            v = default_cfg[k]\n"
"        elseif template_cfg[k] == 'any' then\n"
"            -- any type is ok\n"
"        elseif type(template_cfg[k]) == 'table' then\n"
"            if type(v) ~= 'table' then\n"
"                error(\"Error: cfg parameter '\" .. readable_name .. \"' should be a table\")\n"
"            end\n"
"            v = prepare_cfg(v, default_cfg[k], template_cfg[k], modify_cfg[k], readable_name)\n"
"        elseif (string.find(template_cfg[k], ',') == nil) then\n"
"            -- one type\n"
"            if type(v) ~= template_cfg[k] then\n"
"                error(\"Error: cfg parameter '\" .. readable_name .. \"' should be of type \" .. template_cfg[k])\n"
"            end\n"
"        else\n"
"            local good_types = string.gsub(template_cfg[k], ' ', '');\n"
"            if (string.find(',' .. good_types .. ',', ',' .. type(v) .. ',') == nil) then\n"
"                good_types = string.gsub(good_types, ',', ', ');\n"
"                error(\"Error: cfg parameter '\" .. readable_name .. \"' should be one of types: \" .. template_cfg[k])\n"
"            end\n"
"        end\n"
"        if modify_cfg ~= nil and type(modify_cfg[k]) == 'function' then\n"
"            v = modify_cfg[k](v)\n"
"        end\n"
"        new_cfg[k] = v\n"
"    end\n"
"    return new_cfg\n"
"end\n"
"\n"
"local function apply_default_cfg(cfg, default_cfg)\n"
"    for k,v in pairs(default_cfg) do\n"
"        if cfg[k] == nil then\n"
"            cfg[k] = v\n"
"        elseif type(v) == 'table' then\n"
"            apply_default_cfg(cfg[k], v)\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function reload_cfg(oldcfg, cfg)\n"
"    local newcfg = prepare_cfg(cfg, default_cfg, template_cfg, modify_cfg)\n"
"    -- iterate over original table because prepare_cfg() may store NILs\n"
"    for key in pairs(cfg) do\n"
"        if dynamic_cfg[key] == nil then\n"
"            db.error(db.error.RELOAD_CFG, key);\n"
"        end\n"
"    end\n"
"    for key in pairs(cfg) do\n"
"        local val = newcfg[key]\n"
"        if oldcfg[key] ~= val then\n"
"            dynamic_cfg[key](val)\n"
"            rawset(oldcfg, key, val)\n"
"            log.info(\"set '%s' configuration option to '%s'\", key, val)\n"
"        end\n"
"    end\n"
"    if type(db.on_reload_configuration) == 'function' then\n"
"        db.on_reload_configuration()\n"
"    end\n"
"end\n"
"\n"
"local db = require('db')\n"
"-- Move all db members except 'error' to db_configured\n"
"local db_configured = {}\n"
"for k, v in pairs(db) do\n"
"    db_configured[k] = v\n"
"    -- db.net.db uses db.error and db.internal\n"
"    if k ~= 'error' and k ~= 'internal' and k ~= 'index' then\n"
"        db[k] = nil\n"
"    end\n"
"end\n"
"\n"
"setmetatable(db, {\n"
"    __index = function(table, index)\n"
"        error(debug.traceback(\"Please call db.cfg{} first\"))\n"
"        error(\"Please call db.cfg{} first\")\n"
"     end\n"
"})\n"
"\n"
"local function load_cfg(cfg)\n"
"    cfg = prepare_cfg(cfg, default_cfg, template_cfg, modify_cfg)\n"
"    apply_default_cfg(cfg, default_cfg);\n"
"    -- Save new db.cfg\n"
"    db.cfg = cfg\n"
"    if not pcall(ffi.C.check_cfg) then\n"
"        db.cfg = load_cfg -- restore original db.cfg\n"
"        return db.error() -- re-throw exception from check_cfg()\n"
"    end\n"
"    -- Restore db members after initial configuration\n"
"    for k, v in pairs(db_configured) do\n"
"        db[k] = v\n"
"    end\n"
"    setmetatable(db, nil)\n"
"    db_configured = nil\n"
"    db.cfg = setmetatable(cfg,\n"
"        {\n"
"            __newindex = function(table, index)\n"
"                error('Attempt to modify a read-only table')\n"
"            end,\n"
"            __call = reload_cfg,\n"
"        })\n"
"    ffi.C.load_cfg()\n"
"    for key, fun in pairs(dynamic_cfg) do\n"
"        local val = cfg[key]\n"
"        if val ~= nil and not dynamic_cfg_skip_at_load[key] then\n"
"            fun(cfg[key])\n"
"            if val ~= default_cfg[key] then\n"
"                log.info(\"set '%s' configuration option to '%s'\", key, val)\n"
"            end\n"
"        end\n"
"    end\n"
"end\n"
"db.cfg = load_cfg\n"
"jit.off(load_cfg)\n"
"jit.off(reload_cfg)\n"
"jit.off(db.cfg)\n"
""
;
