const char uuid_lua[] =
"-- uuid.lua (internal file)\n"
"\n"
"local ffi = require(\"ffi\")\n"
"local builtin = ffi.C\n"
"\n"
"ffi.cdef[[\n"
"struct tt_uuid {\n"
"    uint32_t time_low;\n"
"    uint16_t time_mid;\n"
"    uint16_t time_hi_and_version;\n"
"    uint8_t clock_seq_hi_and_reserved;\n"
"    uint8_t clock_seq_low;\n"
"    uint8_t node[6];\n"
"};\n"
"\n"
"void\n"
"tt_uuid_create(struct tt_uuid *uu);\n"
"int\n"
"tt_uuid_from_string(const char *in, struct tt_uuid *uu);\n"
"void\n"
"tt_uuid_to_string(const struct tt_uuid *uu, char *out);\n"
"void\n"
"tt_uuid_bswap(struct tt_uuid *uu);\n"
"bool\n"
"tt_uuid_is_nil(const struct tt_uuid *uu);\n"
"bool\n"
"tt_uuid_is_equal(const struct tt_uuid *lhs, const struct tt_uuid *rhs);\n"
"char *\n"
"tt_uuid_str(const struct tt_uuid *uu);\n"
"extern const struct tt_uuid uuid_nil;\n"
"]]\n"
"\n"
"local uuid_t = ffi.typeof('struct tt_uuid')\n"
"local UUID_STR_LEN = 36\n"
"local UUID_LEN = ffi.sizeof(uuid_t)\n"
"local uuidbuf = ffi.new(uuid_t)\n"
"\n"
"local uuid_tostring = function(uu)\n"
"    if not ffi.istype(uuid_t, uu) then\n"
"        return error('Usage: uuid:str()')\n"
"    end\n"
"    return ffi.string(builtin.tt_uuid_str(uu), UUID_STR_LEN)\n"
"end\n"
"\n"
"local uuid_fromstr = function(str)\n"
"    if type(str) ~= 'string' then\n"
"        error(\"fromstr(str)\")\n"
"    end\n"
"    local uu = ffi.new(uuid_t)\n"
"    local rc = builtin.tt_uuid_from_string(str, uu)\n"
"    if rc ~= 0 then\n"
"        return nil\n"
"    end\n"
"    return uu\n"
"end\n"
"\n"
"local need_bswap = function(order)\n"
"    if order == nil or order == 'l' or order == 'h' or order == 'host' then\n"
"        return false\n"
"    elseif order == 'b' or order == 'n' or order == 'network' then\n"
"        return true\n"
"    else\n"
"        error('invalid byteorder, valid is l, b, h, n')\n"
"    end\n"
"end\n"
"\n"
"local uuid_tobin = function(uu, byteorder)\n"
"    if not ffi.istype(uuid_t, uu) then\n"
"        return error('Usage: uuid:bin([byteorder])')\n"
"    end\n"
"    if need_bswap(byteorder) then\n"
"        if uu ~= uuidbuf then\n"
"            ffi.copy(uuidbuf, uu, UUID_LEN)\n"
"        end\n"
"        builtin.tt_uuid_bswap(uuidbuf)\n"
"        return ffi.string(ffi.cast('char *', uuidbuf), UUID_LEN)\n"
"    end\n"
"    return ffi.string(ffi.cast('char *', uu), UUID_LEN)\n"
"end\n"
"\n"
"local uuid_frombin = function(bin, byteorder)\n"
"    if type(bin) ~= 'string' or #bin ~= UUID_LEN then\n"
"        error(\"frombin(bin, [byteorder])\")\n"
"    end\n"
"    local uu = ffi.new(uuid_t)\n"
"    ffi.copy(uu, bin, UUID_LEN)\n"
"    if need_bswap(byteorder) then\n"
"        builtin.tt_uuid_bswap(uu)\n"
"    end\n"
"    return uu\n"
"end\n"
"\n"
"local uuid_isnil = function(uu)\n"
"    if not ffi.istype(uuid_t, uu) then\n"
"        return error('Usage: uuid:isnil()')\n"
"    end\n"
"    return builtin.tt_uuid_is_nil(uu)\n"
"end\n"
"\n"
"local uuid_eq = function(lhs, rhs)\n"
"    if not ffi.istype(uuid_t, rhs) then\n"
"        return false\n"
"    end\n"
"    if not ffi.istype(uuid_t, lhs) then\n"
"        return error('Usage: uuid == var')\n"
"    end\n"
"    return builtin.tt_uuid_is_equal(lhs, rhs)\n"
"end\n"
"\n"
"local uuid_new = function()\n"
"    local uu = ffi.new(uuid_t)\n"
"    builtin.tt_uuid_create(uu)\n"
"    return uu\n"
"end\n"
"\n"
"local uuid_new_bin = function(byteorder)\n"
"    builtin.tt_uuid_create(uuidbuf)\n"
"    return uuid_tobin(uuidbuf, byteorder)\n"
"end\n"
"local uuid_new_str = function()\n"
"    builtin.tt_uuid_create(uuidbuf)\n"
"    return uuid_tostring(uuidbuf)\n"
"end\n"
"\n"
"local uuid_mt = {\n"
"    __tostring = uuid_tostring;\n"
"    __eq = uuid_eq;\n"
"    __index = {\n"
"        isnil = uuid_isnil;\n"
"        bin   = uuid_tobin;    -- binary host byteorder\n"
"        str   = uuid_tostring; -- RFC4122 string\n"
"    }\n"
"}\n"
"\n"
"ffi.metatype(uuid_t, uuid_mt)\n"
"\n"
"return setmetatable({\n"
"    NULL        = builtin.uuid_nil;\n"
"    new         = uuid_new;\n"
"    fromstr     = uuid_fromstr;\n"
"    frombin     = uuid_frombin;\n"
"    bin         = uuid_new_bin;   -- optimized shortcut for new():bin()\n"
"    str         = uuid_new_str;   -- optimized shortcut for new():str()\n"
"}, {\n"
"    __call = uuid_new; -- shortcut for new()\n"
"})\n"
""
;
