const char fio_lua[] =
"-- fio.lua (internal file)\n"
"\n"
"local fio = require('fio')\n"
"local ffi = require('ffi')\n"
"\n"
"ffi.cdef[[\n"
"    int umask(int mask);\n"
"    char *dirname(char *path);\n"
"]]\n"
"\n"
"local internal = fio.internal\n"
"fio.internal = nil\n"
"\n"
"local function sprintf(fmt, ...)\n"
"    if select('#', ...) == 0 then\n"
"        return fmt\n"
"    end\n"
"    return string.format(fmt, ...)\n"
"end\n"
"\n"
"local fio_methods = {}\n"
"\n"
"fio_methods.read = function(self, size)\n"
"    if size == nil then\n"
"        return ''\n"
"    end\n"
"\n"
"    return internal.read(self.fh, tonumber(size))\n"
"end\n"
"\n"
"fio_methods.write = function(self, data)\n"
"    data = tostring(data)\n"
"    local res = internal.write(self.fh, data, #data)\n"
"    return res >= 0\n"
"end\n"
"\n"
"fio_methods.pwrite = function(self, data, offset)\n"
"    data = tostring(data)\n"
"    local len = #data\n"
"    if len == 0 then\n"
"        return true\n"
"    end\n"
"\n"
"    if offset == nil then\n"
"        offset = 0\n"
"    else\n"
"        offset = tonumber(offset)\n"
"    end\n"
"\n"
"    local res = internal.pwrite(self.fh, data, len, offset)\n"
"    return res >= 0\n"
"end\n"
"\n"
"fio_methods.pread = function(self, len, offset)\n"
"    if len == nil then\n"
"        return ''\n"
"    end\n"
"    if offset == nil then\n"
"        offset = 0\n"
"    end\n"
"\n"
"    return internal.pread(self.fh, tonumber(len), tonumber(offset))\n"
"end\n"
"\n"
"\n"
"fio_methods.truncate = function(self, length)\n"
"    if length == nil then\n"
"        length = 0\n"
"    end\n"
"    return internal.ftruncate(self.fh, length)\n"
"end\n"
"\n"
"fio_methods.seek = function(self, offset, whence)\n"
"    if whence == nil then\n"
"        whence = 'SEEK_SET'\n"
"    end\n"
"    if type(whence) == 'string' then\n"
"        if fio.c.seek[whence] == nil then\n"
"            error(sprintf(\"Unknown whence: %s\", whence))\n"
"        end\n"
"        whence = fio.c.seek[whence]\n"
"    else\n"
"        whence = tonumber(whence)\n"
"    end\n"
"\n"
"    local res = internal.lseek(self.fh, tonumber(offset), whence)\n"
"\n"
"    if res < 0 then\n"
"        return nil\n"
"    end\n"
"    return tonumber(res)\n"
"end\n"
"\n"
"fio_methods.close = function(self)\n"
"    return internal.close(self.fh)\n"
"end\n"
"\n"
"fio_methods.fsync = function(self)\n"
"    return internal.fsync(self.fh)\n"
"end\n"
"\n"
"fio_methods.fdatasync = function(self)\n"
"    return internal.fdatasync(self.fh)\n"
"end\n"
"\n"
"\n"
"fio_methods.stat = function(self)\n"
"    return internal.fstat(self.fh)\n"
"end\n"
"\n"
"\n"
"local fio_mt = { __index = fio_methods }\n"
"\n"
"fio.open = function(path, flags, mode)\n"
"    local iflag = 0\n"
"    local imode = 0\n"
"\n"
"    if type(flags) ~= 'table' then\n"
"        flags = { flags }\n"
"    end\n"
"    if type(mode) ~= 'table' then\n"
"        mode = { mode }\n"
"    end\n"
"\n"
"\n"
"    for _, flag in pairs(flags) do\n"
"        if type(flag) == 'number' then\n"
"            iflag = bit.bor(iflag, flag)\n"
"        else\n"
"            if fio.c.flag[ flag ] == nil then\n"
"                error(sprintf(\"Unknown flag: %s\", flag))\n"
"            end\n"
"            iflag = bit.bor(iflag, fio.c.flag[ flag ])\n"
"        end\n"
"    end\n"
"\n"
"    for _, m in pairs(mode) do\n"
"        if type(m) == 'string' then\n"
"            if fio.c.mode[m] == nil then\n"
"                error(sprintf(\"Unknown mode: %s\", m))\n"
"            end\n"
"            imode = bit.bor(imode, fio.c.mode[m])\n"
"        else\n"
"            imode = bit.bor(imode, tonumber(m))\n"
"        end\n"
"    end\n"
"\n"
"    local fh = internal.open(tostring(path), iflag, imode)\n"
"    if fh < 0 then\n"
"        return nil\n"
"    end\n"
"\n"
"    fh = { fh = fh }\n"
"    setmetatable(fh, fio_mt)\n"
"    return fh\n"
"end\n"
"\n"
"fio.pathjoin = function(path, ...)\n"
"    path = tostring(path)\n"
"    if path == nil or path == '' then\n"
"        error(\"Empty path part\")\n"
"    end\n"
"    for i = 1, select('#', ...) do\n"
"        if string.match(path, '/$') ~= nil then\n"
"            path = string.gsub(path, '/$', '')\n"
"        end\n"
"\n"
"        local sp = select(i, ...)\n"
"        if sp == nil then\n"
"            error(\"Undefined path part\")\n"
"        end\n"
"        if sp == '' or sp == '/' then\n"
"            error(\"Empty path part\")\n"
"        end\n"
"        if string.match(sp, '^/') ~= nil then\n"
"            sp = string.gsub(sp, '^/', '')\n"
"        end\n"
"        if sp ~= '' then\n"
"            path = path .. '/' .. sp\n"
"        end\n"
"    end\n"
"    if string.match(path, '/$') ~= nil and #path > 1 then\n"
"        path = string.gsub(path, '/$', '')\n"
"    end\n"
"\n"
"    return path\n"
"end\n"
"\n"
"fio.basename = function(path, suffix)\n"
"    if path == nil then\n"
"        return nil\n"
"    end\n"
"\n"
"    path = tostring(path)\n"
"    path = string.gsub(path, '.*/', '')\n"
"\n"
"    if suffix ~= nil then\n"
"        suffix = tostring(suffix)\n"
"        if #suffix > 0 then\n"
"            suffix = string.gsub(suffix, '(.)', '[%1]')\n"
"            path = string.gsub(path, suffix, '')\n"
"        end\n"
"    end\n"
"\n"
"    return path\n"
"end\n"
"\n"
"fio.dirname = function(path)\n"
"    if path == nil then\n"
"        return nil\n"
"    end\n"
"    path = tostring(path)\n"
"    path = ffi.new('char[?]', #path + 1, path)\n"
"    return ffi.string(ffi.C.dirname(path))\n"
"end\n"
"\n"
"fio.umask = function(umask)\n"
"\n"
"    if umask == nil then\n"
"        local old = ffi.C.umask(0)\n"
"        ffi.C.umask(old)\n"
"        return old\n"
"    end\n"
"\n"
"    umask = tonumber(umask)\n"
"\n"
"    return ffi.C.umask(tonumber(umask))\n"
"\n"
"end\n"
"\n"
"return fio\n"
""
;
