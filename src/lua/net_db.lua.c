const char net_db_lua[] =
"-- net_db.lua (internal file)\n"
"\n"
"local msgpack = require 'msgpack'\n"
"local fiber = require 'fiber'\n"
"local socket = require 'socket'\n"
"local log = require 'log'\n"
"local errno = require 'errno'\n"
"local ffi = require 'ffi'\n"
"local digest = require 'digest'\n"
"local yaml = require 'yaml'\n"
"local urilib = require 'uri'\n"
"\n"
"-- packet codes\n"
"local OK                = 0\n"
"local SELECT            = 1\n"
"local INSERT            = 2\n"
"local REPLACE           = 3\n"
"local UPDATE            = 4\n"
"local DELETE            = 5\n"
"local CALL              = 6\n"
"local AUTH              = 7\n"
"local EVAL              = 8\n"
"local PING              = 64\n"
"local ERROR_TYPE        = 65536\n"
"\n"
"-- packet keys\n"
"local TYPE              = 0x00\n"
"local SYNC              = 0x01\n"
"local SPACE_ID          = 0x10\n"
"local INDEX_ID          = 0x11\n"
"local LIMIT             = 0x12\n"
"local OFFSET            = 0x13\n"
"local ITERATOR          = 0x14\n"
"local INDEX_BASE        = 0x15\n"
"local KEY               = 0x20\n"
"local TUPLE             = 0x21\n"
"local FUNCTION_NAME     = 0x22\n"
"local USER              = 0x23\n"
"local EXPR              = 0x27\n"
"local DATA              = 0x30\n"
"local ERROR             = 0x31\n"
"local GREETING_SIZE     = 128\n"
"\n"
"local SPACE_SPACE_ID    = 280\n"
"local SPACE_INDEX_ID    = 288\n"
"\n"
"local TIMEOUT_INFINITY  = 500 * 365 * 86400\n"
"\n"
"local sequence_mt = { __serialize = 'sequence' }\n"
"local mapping_mt = { __serialize = 'mapping' }\n"
"\n"
"local CONSOLE_FAKESYNC  = 15121974\n"
"local CONSOLE_DELIMITER = \"$EOF$\"\n"
"\n"
"local function request(header, body)\n"
"    -- hint msgpack to always encode header and body as a map\n"
"    header = msgpack.encode(setmetatable(header, mapping_mt))\n"
"    body = msgpack.encode(setmetatable(body, mapping_mt))\n"
"\n"
"    local len = msgpack.encode(string.len(header) + string.len(body))\n"
"\n"
"    return len .. header .. body\n"
"end\n"
"\n"
"\n"
"local function strxor(s1, s2)\n"
"    local res = ''\n"
"    for i = 1, string.len(s1) do\n"
"        if i > string.len(s2) then\n"
"            break\n"
"        end\n"
"\n"
"        local b1 = string.byte(s1, i)\n"
"        local b2 = string.byte(s2, i)\n"
"        res = res .. string.char(bit.bxor(b1, b2))\n"
"    end\n"
"    return res\n"
"end\n"
"\n"
"local function keyfy(v)\n"
"    if type(v) == 'table' then\n"
"        return v\n"
"    end\n"
"    if v == nil then\n"
"        return {}\n"
"    end\n"
"    return { v }\n"
"end\n"
"\n"
"local function one_tuple(tbl)\n"
"    if tbl == nil then\n"
"        return\n"
"    end\n"
"    if #tbl > 0 then\n"
"        return tbl[1]\n"
"    end\n"
"    return\n"
"end\n"
"\n"
"local proto = {\n"
"    _sync = -1,\n"
"\n"
"    -- sync\n"
"    sync    = function(self)\n"
"        self._sync = self._sync + 1\n"
"        if self._sync >= 0x7FFFFFFF then\n"
"            self._sync = 0\n"
"        end\n"
"        return self._sync\n"
"    end,\n"
"\n"
"\n"
"    ping    = function(sync)\n"
"        return request(\n"
"            { [SYNC] = sync, [TYPE] = PING },\n"
"            {}\n"
"        )\n"
"    end,\n"
"\n"
"\n"
"    -- lua call\n"
"    call = function(sync, proc, args)\n"
"        if args == nil then\n"
"            args = {}\n"
"        end\n"
"        return request(\n"
"            { [SYNC] = sync, [TYPE] = CALL  },\n"
"            { [FUNCTION_NAME] = proc, [TUPLE] = args }\n"
"        )\n"
"    end,\n"
"\n"
"    -- lua eval\n"
"    eval = function(sync, expr, args)\n"
"        if args == nil then\n"
"            args = {}\n"
"        end\n"
"        return request(\n"
"            { [SYNC] = sync, [TYPE] = EVAL  },\n"
"            { [EXPR] = expr, [TUPLE] = args }\n"
"        )\n"
"    end,\n"
"\n"
"    -- insert\n"
"    insert = function(sync, spaceno, tuple)\n"
"        return request(\n"
"            { [SYNC] = sync, [TYPE] = INSERT },\n"
"            { [SPACE_ID] = spaceno, [TUPLE] = tuple }\n"
"        )\n"
"    end,\n"
"\n"
"    -- replace\n"
"    replace = function(sync, spaceno, tuple)\n"
"        return request(\n"
"            { [SYNC] = sync, [TYPE] = REPLACE },\n"
"            { [SPACE_ID] = spaceno, [TUPLE] = tuple }\n"
"        )\n"
"    end,\n"
"\n"
"    -- delete\n"
"    delete = function(sync, spaceno, key)\n"
"        return request(\n"
"            { [SYNC] = sync, [TYPE] = DELETE },\n"
"            { [SPACE_ID] = spaceno, [KEY] = keyfy(key) }\n"
"        )\n"
"    end,\n"
"\n"
"    -- update\n"
"    update = function(sync, spaceno, key, oplist)\n"
"        return request(\n"
"            { [SYNC] = sync, [TYPE] = UPDATE },\n"
"            { [KEY] = keyfy(key), [INDEX_BASE] = 1 , [TUPLE]  = oplist,\n"
"              [SPACE_ID] = spaceno }\n"
"        )\n"
"    end,\n"
"\n"
"    -- select\n"
"    select = function(sync, spaceno, indexno, key, opts)\n"
"        if opts == nil then\n"
"            opts = {}\n"
"        end\n"
"        if spaceno == nil or type(spaceno) ~= 'number' then\n"
"            db.error(db.error.NO_SUCH_SPACE, '#'..tostring(spaceno))\n"
"        end\n"
"\n"
"        if indexno == nil or type(indexno) ~= 'number' then\n"
"            db.error(db.error.NO_SUCH_INDEX, indexno, '#'..tostring(spaceno))\n"
"        end\n"
"\n"
"        local body = {\n"
"            [SPACE_ID] = spaceno,\n"
"            [INDEX_ID] = indexno,\n"
"            [KEY] = keyfy(key)\n"
"        }\n"
"\n"
"        if opts.limit ~= nil then\n"
"            body[LIMIT] = tonumber(opts.limit)\n"
"        else\n"
"            body[LIMIT] = 0xFFFFFFFF\n"
"        end\n"
"        if opts.offset ~= nil then\n"
"            body[OFFSET] = tonumber(opts.offset)\n"
"        else\n"
"            body[OFFSET] = 0\n"
"        end\n"
"\n"
"        if opts.iterator ~= nil then\n"
"            if type(opts.iterator) == 'string' then\n"
"                local iterator = db.index[ opts.iterator ]\n"
"                if iterator == nil then\n"
"                    db.error(db.error.ITERATOR_TYPE, tostring(opts.iterator))\n"
"                end\n"
"                body[ITERATOR] = iterator\n"
"            else\n"
"                body[ITERATOR] = tonumber(opts.iterator)\n"
"            end\n"
"        end\n"
"\n"
"        return request( { [SYNC] = sync, [TYPE] = SELECT }, body )\n"
"    end,\n"
"\n"
"    auth = function(sync, user, password, handshake)\n"
"        local saltb64 = string.sub(handshake, 65)\n"
"        local salt = string.sub(digest.base64_decode(saltb64), 1, 20)\n"
"\n"
"        local hpassword = digest.sha1(password)\n"
"        local hhpassword = digest.sha1(hpassword)\n"
"        local scramble = digest.sha1(salt .. hhpassword)\n"
"\n"
"        local hash = strxor(hpassword, scramble)\n"
"        return request(\n"
"            { [SYNC] = sync, [TYPE] = AUTH },\n"
"            { [USER] = user, [TUPLE] = { 'chap-sha1', hash } }\n"
"        )\n"
"    end,\n"
"\n"
"    b64decode = digest.base64_decode,\n"
"}\n"
"\n"
"\n"
"local function check_if_space(space)\n"
"    if type(space) == 'table' and space.id ~= nil then\n"
"        return\n"
"    end\n"
"    error(\"Use space:method(...) instead space.method(...)\")\n"
"end\n"
"\n"
"local function space_metatable(self)\n"
"    return {\n"
"        __index = {\n"
"            insert  = function(space, tuple)\n"
"                check_if_space(space)\n"
"                return self:_insert(space.id, tuple)\n"
"            end,\n"
"\n"
"            replace = function(space, tuple)\n"
"                check_if_space(space)\n"
"                return self:_replace(space.id, tuple)\n"
"            end,\n"
"\n"
"            select = function(space, key, opts)\n"
"                check_if_space(space)\n"
"                return self:_select(space.id, 0, key, opts)\n"
"            end,\n"
"\n"
"            delete = function(space, key)\n"
"                check_if_space(space)\n"
"                return self:_delete(space.id, key)\n"
"            end,\n"
"\n"
"            update = function(space, key, oplist)\n"
"                check_if_space(space)\n"
"                return self:_update(space.id, key, oplist)\n"
"            end,\n"
"\n"
"            get = function(space, key)\n"
"                check_if_space(space)\n"
"                local res = self:_select(space.id, 0, key,\n"
"                                    { limit = 2, iterator = 'EQ' })\n"
"                if #res == 0 then\n"
"                    return\n"
"                end\n"
"                if #res == 1 then\n"
"                    return res[1]\n"
"                end\n"
"                db.error(db.error.MORE_THAN_ONE_TUPLE)\n"
"            end\n"
"        }\n"
"    }\n"
"end\n"
"\n"
"local function check_if_index(idx)\n"
"    if type(idx) == 'table' and idx.id ~= nil and type(idx.space) == 'table' then\n"
"        return\n"
"    end\n"
"    error('Use index:method(...) instead index.method(...)')\n"
"end\n"
"\n"
"local function index_metatable(self)\n"
"    return {\n"
"        __index = {\n"
"            select = function(idx, key, opts)\n"
"                check_if_index(idx)\n"
"                return self:_select(idx.space.id, idx.id, key, opts)\n"
"            end,\n"
"\n"
"            get = function(idx, key)\n"
"                check_if_index(idx)\n"
"                local res = self:_select(idx.space.id, idx.id, key,\n"
"                                    { limit = 2, iterator = 'EQ' })\n"
"                if #res == 0 then\n"
"                    return\n"
"                end\n"
"                if #res == 1 then\n"
"                    return res[1]\n"
"                end\n"
"                db.error(db.error.MORE_THAN_ONE_TUPLE)\n"
"            end,\n"
"\n"
"            min = function(idx, key)\n"
"                check_if_index(idx)\n"
"                local res = self:_select(idx.space.id, idx.id, key,\n"
"                    { limit = 1, iterator = 'GE' })\n"
"                if #res > 0 then\n"
"                    return res[1]\n"
"                end\n"
"            end,\n"
"\n"
"            max = function(idx, key)\n"
"                check_if_index(idx)\n"
"                local res = self:_select(idx.space.id, idx.id, key,\n"
"                    { limit = 1, iterator = 'LE' })\n"
"                if #res > 0 then\n"
"                    return res[1]\n"
"                end\n"
"            end,\n"
"\n"
"            count = function(idx, key)\n"
"                check_if_index(idx)\n"
"                local proc = string.format('db.space.%s.index.%s:count',\n"
"                    idx.space.name, idx.name)\n"
"                local res = self:call(proc, key)\n"
"                if #res > 0 then\n"
"                    return res[1][1]\n"
"                end\n"
"            end\n"
"        }\n"
"    }\n"
"end\n"
"\n"
"local errno_is_transient = {\n"
"    [errno.EAGAIN] = true;\n"
"    [errno.EWOULDBLOCK] = true;\n"
"    [errno.EINTR] = true;\n"
"}\n"
"\n"
"local remote = {}\n"
"\n"
"local remote_methods = {\n"
"    proto = proto,\n"
"\n"
"    new = function(cls, host, port, opts)\n"
"        local self = {}\n"
"\n"
"        if type(cls) == 'table' then\n"
"            setmetatable(self, getmetatable(cls))\n"
"        else\n"
"            host, port, opts = cls, host, port\n"
"            setmetatable(self, getmetatable(remote))\n"
"        end\n"
"\n"
"\n"
"        -- uri as the first argument\n"
"        if opts == nil then\n"
"            opts = {}\n"
"            if type(port) == 'table' then\n"
"                opts = port\n"
"                port = nil\n"
"            end\n"
"\n"
"            if port == nil then\n"
"\n"
"                local address = urilib.parse(tostring(host))\n"
"                if address == nil or address.service == nil then\n"
"                    db.error(db.error.PROC_LUA,\n"
"                        \"usage: remote:new(uri[, opts] | host, port[, opts])\")\n"
"                end\n"
"\n"
"                host = address.host\n"
"                port = address.service\n"
"\n"
"                opts.user = address.login or opts.user\n"
"                opts.password = address.password or opts.password\n"
"            end\n"
"        end\n"
"\n"
"\n"
"        self.is_instance = true\n"
"        self.host = host\n"
"        self.port = port\n"
"        self.opts = opts\n"
"\n"
"        if self.opts == nil then\n"
"            self.opts = {}\n"
"        end\n"
"\n"
"        if self.opts.user ~= nil and self.opts.password == nil then\n"
"            db.error(db.error.PROC_LUA,\n"
"                \"net.db: password is not defined\")\n"
"        end\n"
"        if self.opts.user == nil and self.opts.password ~= nil then\n"
"            db.error(db.error.PROC_LUA,\n"
"                \"net.db: user is not defined\")\n"
"        end\n"
"\n"
"\n"
"        if self.host == nil then\n"
"            self.host = 'localhost'\n"
"        end\n"
"\n"
"        self.is_run = true\n"
"        self.state = 'init'\n"
"        self.wbuf = {}\n"
"        self.rbuf = ''\n"
"        self.rpos = 1\n"
"        self.rlen = 0\n"
"\n"
"        self.ch = { sync = {}, fid = {} }\n"
"        self.wait = { state = {} }\n"
"        self.timeouts = {}\n"
"\n"
"        fiber.create(function() self:_connect_worker() end)\n"
"        fiber.create(function() self:_read_worker() end)\n"
"        fiber.create(function() self:_write_worker() end)\n"
"\n"
"        if self.opts.wait_connected == nil or self.opts.wait_connected then\n"
"            self:wait_connected()\n"
"        end\n"
"\n"
"        return self\n"
"    end,\n"
"\n"
"\n"
"    ping    = function(self)\n"
"        if type(self) ~= 'table' then\n"
"            db.error(db.error.PROC_LUA, \"usage: remote:ping()\")\n"
"        end\n"
"        if not self:is_connected() then\n"
"            return false\n"
"        end\n"
"        local sync = self.proto:sync()\n"
"        local req = self.proto.ping(sync)\n"
"\n"
"        local res = self:_request('ping', false)\n"
"\n"
"\n"
"        if res == nil then\n"
"            return false\n"
"        end\n"
"\n"
"        if res.hdr[TYPE] == OK then\n"
"            return true\n"
"        end\n"
"        return false\n"
"    end,\n"
"\n"
"    _console = function(self, line)\n"
"        local res = self:_request_raw('eval', CONSOLE_FAKESYNC,\n"
"            line..CONSOLE_DELIMITER..\"\\n\", true)\n"
"        return res.body[DATA]\n"
"    end,\n"
"\n"
"    call    = function(self, proc_name, ...)\n"
"        if type(self) ~= 'table' then\n"
"            db.error(db.error.PROC_LUA, \"usage: remote:call(proc_name, ...)\")\n"
"        end\n"
"\n"
"        proc_name = tostring(proc_name)\n"
"\n"
"        local res = self:_request('call', true, proc_name, {...})\n"
"        return res.body[DATA]\n"
"\n"
"    end,\n"
"\n"
"    eval    = function(self, expr, ...)\n"
"        if type(self) ~= 'table' then\n"
"            db.error(db.error.PROC_LUA, \"usage: remote:eval(expr, ...)\")\n"
"        end\n"
"\n"
"        expr = tostring(expr)\n"
"        local data = self:_request('eval', true, expr, {...}).body[DATA]\n"
"        local data_len = #data\n"
"        if data_len == 1 then\n"
"            return data[1]\n"
"        elseif data_len == 0 then\n"
"            return\n"
"        else\n"
"            return unpack(data)\n"
"        end\n"
"    end,\n"
"\n"
"    is_connected = function(self)\n"
"        return self.state == 'active' or self.state == 'activew'\n"
"    end,\n"
"\n"
"    wait_connected = function(self, timeout)\n"
"        return self:_wait_state(self._request_states, timeout)\n"
"    end,\n"
"\n"
"    timeout = function(self, timeout)\n"
"        if timeout == nil then\n"
"            return self\n"
"        end\n"
"        if self.is_instance then\n"
"            self.timeouts[ fiber.id() ] = timeout\n"
"            return self\n"
"        end\n"
"\n"
"        return {\n"
"            new = function(cls, host, port, opts)\n"
"                if opts == nil then\n"
"                    opts = {}\n"
"                end\n"
"\n"
"                opts.wait_connected = false\n"
"\n"
"                local cn = self:new(host, port, opts)\n"
"\n"
"                if not cn:wait_connected(timeout) then\n"
"                    cn:close()\n"
"                    db.error(db.error.TIMEOUT)\n"
"                end\n"
"                return cn\n"
"            end\n"
"        }\n"
"    end,\n"
"\n"
"    reload_schema = function(self)\n"
"         self:_load_schema()\n"
"         if self.state ~= 'error' and self.state ~= 'closed' then\n"
"               self:_switch_state('active')\n"
"         end\n"
"    end,\n"
"\n"
"    close = function(self)\n"
"        if self.state ~= 'closed' then\n"
"            self:_switch_state('closed')\n"
"            self:_error_waiters('Connection was closed')\n"
"            if self.s ~= nil then\n"
"                self.s:close()\n"
"                self.s = nil\n"
"            end\n"
"        end\n"
"    end,\n"
"\n"
"    -- private methods\n"
"    _fatal = function(self, efmt, ...)\n"
"        if self.state == 'error' then\n"
"            return\n"
"        end\n"
"        local emsg = efmt\n"
"        if select('#', ...) > 0 then\n"
"            emsg = string.format(efmt, ...)\n"
"        end\n"
"\n"
"        if self.s ~= nil then\n"
"            self.s:close()\n"
"            self.s = nil\n"
"        end\n"
"\n"
"        log.warn(\"%s:%s: %s\", self.host or \"\", self.port or \"\", tostring(emsg))\n"
"        self.error = emsg\n"
"        self.space = {}\n"
"        self:_switch_state('error')\n"
"        self:_error_waiters(emsg)\n"
"        self.rbuf = ''\n"
"        self.rpos = 1\n"
"        self.rlen = 0\n"
"        self.wbuf = {}\n"
"        self.handshake = ''\n"
"    end,\n"
"\n"
"    _error_waiters = function(self, emsg)\n"
"        local waiters = self.ch.sync\n"
"        self.ch.sync = {}\n"
"        for sync, channel in pairs(waiters) do\n"
"            channel:put{\n"
"                hdr = {\n"
"                    [TYPE] = bit.bor(ERROR_TYPE, db.error.NO_CONNECTION),\n"
"                    [SYNC] = sync\n"
"                },\n"
"                body = {\n"
"                    [ERROR] = emsg\n"
"                }\n"
"            }\n"
"        end\n"
"    end,\n"
"\n"
"    _check_console_response = function(self)\n"
"        while true do\n"
"            local docend = \"\\n...\\n\"\n"
"            if self.rlen < #docend or\n"
"                string.sub(self.rbuf, #self.rbuf + 1 - #docend) ~= docend then\n"
"                break\n"
"            end\n"
"            local resp = string.sub(self.rbuf, self.rpos)\n"
"            local len = #resp\n"
"            self.rpos = self.rpos + len\n"
"            self.rlen = self.rlen - len\n"
"\n"
"            local hdr = { [SYNC] = CONSOLE_FAKESYNC, [TYPE] = 0 }\n"
"            local body = { [DATA] = resp }\n"
"\n"
"            if self.ch.sync[CONSOLE_FAKESYNC] ~= nil then\n"
"                self.ch.sync[CONSOLE_FAKESYNC]:put({hdr = hdr, body = body })\n"
"                self.ch.sync[CONSOLE_FAKESYNC] = nil\n"
"            else\n"
"                log.warn(\"Unexpected console response: %s\", resp)\n"
"            end\n"
"        end\n"
"    end,\n"
"\n"
"    _check_binary_response = function(self)\n"
"        while true do\n"
"            if self.rlen < 5 then\n"
"                break\n"
"            end\n"
"\n"
"            local len, off = msgpack.decode(self.rbuf, self.rpos)\n"
"            -- wait for correct package length\n"
"            if off + len > #self.rbuf + 1 then\n"
"                break\n"
"            end\n"
"\n"
"            local hdr, body\n"
"            hdr, off = msgpack.decode(self.rbuf, off)\n"
"            if off <= #self.rbuf then\n"
"                body, off = msgpack.decode(self.rbuf, off)\n"
"                -- disable YAML flow output (useful for admin console)\n"
"                setmetatable(body, mapping_mt)\n"
"            else\n"
"                body = {}\n"
"            end\n"
"\n"
"            self.rpos = off\n"
"            self.rlen = #self.rbuf + 1 - self.rpos\n"
"\n"
"            local sync = hdr[SYNC]\n"
"\n"
"            if self.ch.sync[sync] ~= nil then\n"
"                self.ch.sync[sync]:put({ hdr = hdr, body = body })\n"
"                self.ch.sync[sync] = nil\n"
"            else\n"
"                log.warn(\"Unexpected response %s\", tostring(sync))\n"
"            end\n"
"        end\n"
"    end,\n"
"\n"
"    _switch_state = function(self, state)\n"
"        if self.state == state or state == nil then\n"
"            return\n"
"        end\n"
"        self.state = state\n"
"\n"
"        local list = self.wait.state[ state ] or {}\n"
"        self.wait.state[ state ] = {}\n"
"\n"
"        for _, fid in pairs(list) do\n"
"            if fid ~= fiber.id() then\n"
"                if self.ch.fid[fid] ~= nil then\n"
"                    self.ch.fid[fid]:put(true)\n"
"                    self.ch.fid[fid] = nil\n"
"                end\n"
"            end\n"
"        end\n"
"    end,\n"
"\n"
"    _wait_state = function(self, states, timeout)\n"
"        timeout = timeout or TIMEOUT_INFINITY\n"
"        while timeout > 0 and self:_is_state(states) ~= true do\n"
"            local started = fiber.time()\n"
"            local fid = fiber.id()\n"
"            local ch = fiber.channel()\n"
"            for state, _ in pairs(states) do\n"
"                self.wait.state[state] = self.wait.state[state] or {}\n"
"                self.wait.state[state][fid] = fid\n"
"            end\n"
"\n"
"            self.ch.fid[fid] = ch\n"
"            ch:get(timeout)\n"
"            self.ch.fid[fid] = nil\n"
"\n"
"            for state, _ in pairs(states) do\n"
"                self.wait.state[state][fid] = nil\n"
"            end\n"
"            timeout = timeout - (fiber.time() - started)\n"
"        end\n"
"        return self.state\n"
"    end,\n"
"\n"
"\n"
"    _connect_worker = function(self)\n"
"        fiber.name('net.db.connector')\n"
"        local connect_states = { init = true, error = true, closed = true }\n"
"        while self:_wait_state(connect_states) ~= 'closed' do\n"
"\n"
"            if self.state == 'error' then\n"
"                if self.opts.reconnect_after == nil then\n"
"                    self:_switch_state('closed')\n"
"                    return\n"
"                end\n"
"                fiber.sleep(self.opts.reconnect_after)\n"
"            end\n"
"\n"
"            self:_switch_state('connecting')\n"
"\n"
"            self.s = socket.tcp_connect(self.host, self.port)\n"
"            if self.s == nil then\n"
"                self:_fatal(errno.strerror(errno()))\n"
"            else\n"
"\n"
"                -- on_connect\n"
"                self:_switch_state('handshake')\n"
"                self.handshake = self.s:read(128)\n"
"                if self.handshake == nil then\n"
"                    self:_fatal(errno.strerror(errno()))\n"
"                elseif string.len(self.handshake) ~= 128 then\n"
"                    self:_fatal(\"Can't read handshake\")\n"
"                else\n"
"                    if string.match(self.handshake, '^Bee .*console') then\n"
"                        -- enable self:console() method\n"
"                        self.console = self._console\n"
"                        self._check_response = self._check_console_response\n"
"                        -- set delimiter\n"
"                        self:_switch_state('schema')\n"
"                        local res = self:_request_raw('eval', CONSOLE_FAKESYNC,\n"
"                            \"require('console').delimiter('\"..CONSOLE_DELIMITER..\"')\\n\\n\",\n"
"                            true)\n"
"                        if res.hdr[TYPE] ~= OK then\n"
"                            self:_fatal(res.body[ERROR])\n"
"                        end\n"
"                        self:_switch_state('active')\n"
"                    else\n"
"                        self.console = nil\n"
"                        self._check_response = self._check_binary_response\n"
"                        local s, e = pcall(function()\n"
"                            self:_auth()\n"
"                        end)\n"
"                        if not s then\n"
"                            self:_fatal(e)\n"
"                        end\n"
"\n"
"                        xpcall(function() self:_load_schema() end,\n"
"                            function(e)\n"
"                                log.error(\"Can't load schema: %s\", tostring(e))\n"
"                            end)\n"
"\n"
"                        if self.state ~= 'error' and self.state ~= 'closed' then\n"
"                            self:_switch_state('active')\n"
"                        end\n"
"                    end\n"
"                end\n"
"            end\n"
"        end\n"
"    end,\n"
"\n"
"    _auth = function(self)\n"
"        if self.opts.user == nil or self.opts.password == nil then\n"
"            return\n"
"        end\n"
"\n"
"        self:_switch_state('auth')\n"
"\n"
"        local auth_res = self:_request_internal('auth',\n"
"            false, self.opts.user, self.opts.password, self.handshake)\n"
"\n"
"        if auth_res.hdr[TYPE] ~= OK then\n"
"            self:_fatal(auth_res.body[ERROR])\n"
"        end\n"
"    end,\n"
"\n"
"    -- states wakeup _read_worker\n"
"    _r_states = {\n"
"        active = true, activew = true, schema = true,\n"
"        schemaw = true, auth = true, authw = true,\n"
"        closed = true,\n"
"    },\n"
"    -- states wakeup _write_worker\n"
"    _rw_states = {\n"
"        activew = true, schemaw = true, authw = true,\n"
"        closed = true,\n"
"    },\n"
"    _request_states = {\n"
"        active = true, activew = true, closed = true,\n"
"    },\n"
"\n"
"    _is_state = function(self, states)\n"
"        return states[self.state] ~= nil\n"
"    end,\n"
"\n"
"    _is_r_state = function(self)\n"
"        return is_state(self._r_states)\n"
"    end,\n"
"\n"
"    _is_rw_state = function(self)\n"
"        return is_state(self._rw_states)\n"
"    end,\n"
"\n"
"    _load_schema = function(self)\n"
"        if self.state == 'closed' or self.state == 'error' then\n"
"            self:_fatal('Can not load schema from the state')\n"
"            return\n"
"        end\n"
"\n"
"        self:_switch_state('schema')\n"
"\n"
"        local spaces = self:_request_internal('select',\n"
"            true, SPACE_SPACE_ID, 0, nil, { iterator = 'ALL' }).body[DATA]\n"
"        local indexes = self:_request_internal('select',\n"
"            true, SPACE_INDEX_ID, 0, nil, { iterator = 'ALL' }).body[DATA]\n"
"\n"
"        local sl = {}\n"
"\n"
"        for _, space in pairs(spaces) do\n"
"            local name = space[3]\n"
"            local id = space[1]\n"
"            local engine = space[4]\n"
"            local field_count = space[5]\n"
"\n"
"            local s = {\n"
"                id              = id,\n"
"                name            = name,\n"
"                engine          = engine,\n"
"                field_count     = field_count,\n"
"                enabled         = true,\n"
"                index           = {}\n"
"            }\n"
"            if #space > 5 and string.match(space[6], 'temporary') then\n"
"                s.temporary = true\n"
"            else\n"
"                s.temporary = false\n"
"            end\n"
"\n"
"            setmetatable(s, space_metatable(self))\n"
"\n"
"            sl[id] = s\n"
"            sl[name] = s\n"
"        end\n"
"\n"
"        for _, index in pairs(indexes) do\n"
"            local idx = {\n"
"                space   = index[1],\n"
"                id      = index[2],\n"
"                name    = index[3],\n"
"                type    = string.upper(index[4]),\n"
"                parts   = {},\n"
"            }\n"
"\n"
"            if index[5] == 0 then\n"
"                idx.unique = false\n"
"            else\n"
"                idx.unique = true\n"
"            end\n"
"\n"
"            for k = 0, index[6] - 1 do\n"
"                local pktype = index[7 + k * 2 + 1]\n"
"                local pkfield = index[7 + k * 2]\n"
"\n"
"                local pk = {\n"
"                    type = string.upper(pktype),\n"
"                    fieldno = pkfield\n"
"                }\n"
"                idx.parts[k] = pk\n"
"            end\n"
"\n"
"            if sl[idx.space] ~= nil then\n"
"                sl[idx.space].index[idx.id] = idx\n"
"                sl[idx.space].index[idx.name] = idx\n"
"                idx.space = sl[idx.space]\n"
"                setmetatable(idx, index_metatable(self))\n"
"            end\n"
"        end\n"
"\n"
"        self.space = sl\n"
"    end,\n"
"\n"
"    _read_worker = function(self)\n"
"        fiber.name('net.db.read')\n"
"        while self:_wait_state(self._r_states) ~= 'closed' do\n"
"            if self.s:readable() then\n"
"                local data = self.s:sysread()\n"
"\n"
"                if data ~= nil then\n"
"                    if #data == 0 then\n"
"                        self:_fatal('Remote host closed connection')\n"
"                    else\n"
"                        self.rbuf = string.sub(self.rbuf, self.rpos) ..\n"
"                                    data\n"
"                        self.rpos = 1\n"
"                        self.rlen = #self.rbuf\n"
"                        self:_check_response()\n"
"                    end\n"
"                elseif errno_is_transient[errno()] ~= true then\n"
"                    self:_fatal(errno.strerror(errno()))\n"
"                end\n"
"            end\n"
"        end\n"
"    end,\n"
"\n"
"    _to_wstate = { active = 'activew', schema = 'schemaw', auth = 'authw' },\n"
"    _to_rstate = { activew = 'active', schemaw = 'schema', authw = 'auth' },\n"
"\n"
"    _write_worker = function(self)\n"
"        fiber.name('net.db.write')\n"
"        while self:_wait_state(self._rw_states) ~= 'closed' do\n"
"            while self.wbuf[1] ~= nil do\n"
"                local s = table.concat(self.wbuf)\n"
"                self.wbuf = {}\n"
"                local written = self.s:syswrite(s)\n"
"                if written ~= nil then\n"
"                    if written ~= #s then\n"
"                        table.insert(self.wbuf, string.sub(s, written + 1))\n"
"                    end\n"
"                else\n"
"                    table.insert(self.wbuf, s)\n"
"                    if errno_is_transient[errno()] then\n"
"                    -- the write is with a timeout to detect FIN\n"
"                    -- packet on the receiving end, and close the connection.\n"
"                    -- Every second sockets we iterate the while loop\n"
"                    -- and check the connection state\n"
"                        while self.s:writable(1) == 0 and self.state ~= 'closed' do\n"
"                        end\n"
"                    else\n"
"                        self:_fatal(errno.strerror(errno()))\n"
"                        break\n"
"                    end\n"
"                end\n"
"            end\n"
"            self:_switch_state(self._to_rstate[self.state])\n"
"        end\n"
"    end,\n"
"\n"
"    _request = function(self, name, raise, ...)\n"
"        if self.console then\n"
"            db.error(db.error.UNSUPPORTED, \"console\", name)\n"
"        end\n"
"        local fid = fiber.id()\n"
"        if self.timeouts[fid] == nil then\n"
"            self.timeouts[fid] = TIMEOUT_INFINITY\n"
"        end\n"
"\n"
"        local started = fiber.time()\n"
"\n"
"        self:_wait_state(self._request_states, self.timeouts[fid])\n"
"\n"
"        self.timeouts[fid] = self.timeouts[fid] - (fiber.time() - started)\n"
"\n"
"        if self.state == 'closed' then\n"
"            if raise then\n"
"                db.error(db.error.NO_CONNECTION)\n"
"            end\n"
"        end\n"
"\n"
"        if self.timeouts[fid] <= 0 then\n"
"            self.timeouts[fid] = nil\n"
"            if raise then\n"
"                db.error(db.error.TIMEOUT)\n"
"            else\n"
"                return {\n"
"                    hdr = { [TYPE] = bit.bor(ERROR_TYPE, db.error.TIMEOUT) },\n"
"                    body = { [ERROR] = 'Timeout exceeded' }\n"
"                }\n"
"            end\n"
"        end\n"
"\n"
"        return self:_request_internal(name, raise, ...)\n"
"    end,\n"
"\n"
"    _request_raw = function(self, name, sync, request, raise)\n"
"\n"
"        local fid = fiber.id()\n"
"        if self.timeouts[fid] == nil then\n"
"            self.timeouts[fid] = TIMEOUT_INFINITY\n"
"        end\n"
"\n"
"        table.insert(self.wbuf, request)\n"
"\n"
"        self:_switch_state(self._to_wstate[self.state])\n"
"\n"
"        local ch = fiber.channel()\n"
"\n"
"        self.ch.sync[sync] = ch\n"
"\n"
"        local response = ch:get(self.timeouts[fid])\n"
"        self.ch.sync[sync] = nil\n"
"        self.timeouts[fid] = nil\n"
"\n"
"\n"
"        if response == nil then\n"
"            if raise then\n"
"                db.error(db.error.TIMEOUT)\n"
"            else\n"
"                return {\n"
"                    hdr = { [TYPE] = bit.bor(ERROR_TYPE, db.error.TIMEOUT) },\n"
"                    body = { [ERROR] = 'Timeout exceeded' }\n"
"                }\n"
"            end\n"
"        end\n"
"\n"
"        if raise and response.hdr[TYPE] ~= OK then\n"
"            db.error({\n"
"                code = bit.band(response.hdr[TYPE], bit.lshift(1, 15) - 1),\n"
"                reason = response.body[ERROR]\n"
"            })\n"
"        end\n"
"\n"
"        if response.body[DATA] ~= nil and name ~= 'eval' then\n"
"            if rawget(db, 'tuple') ~= nil then\n"
"                for i, v in pairs(response.body[DATA]) do\n"
"                    response.body[DATA][i] =\n"
"                        db.tuple.new(response.body[DATA][i])\n"
"                end\n"
"            end\n"
"            -- disable YAML flow output (useful for admin console)\n"
"            setmetatable(response.body[DATA], sequence_mt)\n"
"        end\n"
"\n"
"        return response\n"
"    end,\n"
"\n"
"    _request_internal = function(self, name, raise, ...)\n"
"        local sync = self.proto:sync()\n"
"        local request = self.proto[name](sync, ...)\n"
"        return self:_request_raw(name, sync, request, raise)\n"
"    end,\n"
"\n"
"    -- private (low level) methods\n"
"    _select = function(self, spaceno, indexno, key, opts)\n"
"        local res = self:_request('select', true, spaceno, indexno, key, opts)\n"
"        return res.body[DATA]\n"
"    end,\n"
"\n"
"    _insert = function(self, spaceno, tuple)\n"
"        local res = self:_request('insert', true, spaceno, tuple)\n"
"        return one_tuple(res.body[DATA])\n"
"    end,\n"
"\n"
"    _replace = function(self, spaceno, tuple)\n"
"        local res = self:_request('replace', true, spaceno, tuple)\n"
"        return one_tuple(res.body[DATA])\n"
"    end,\n"
"\n"
"    _delete  = function(self, spaceno, key)\n"
"        local res = self:_request('delete', true, spaceno, key)\n"
"        return one_tuple(res.body[DATA])\n"
"    end,\n"
"\n"
"    _update = function(self, spaceno, key, oplist)\n"
"        local res = self:_request('update', true, spaceno, key, oplist)\n"
"        return one_tuple(res.body[DATA])\n"
"    end\n"
"}\n"
"\n"
"setmetatable(remote, { __index = remote_methods })\n"
"\n"
"remote.self = {\n"
"    ping = function() return true end,\n"
"    reload_schema = function() end,\n"
"    close = function() end,\n"
"    timeout = function(self) return self end,\n"
"    wait_connected = function(self) return true end,\n"
"    is_connected = function(self) return true end,\n"
"    call = function(_db, proc_name, ...)\n"
"        if type(_db) ~= 'table' then\n"
"            db.error(db.error.PROC_LUA, \"usage: remote:call(proc_name, ...)\")\n"
"        end\n"
"        proc_name = tostring(proc_name)\n"
"        local proc = { package.loaded['db.internal']\n"
"            .call_loadproc(proc_name) }\n"
"        local result\n"
"        if #proc == 2 then\n"
"            result = { proc[1](proc[2], ...) }\n"
"        else\n"
"            result = { proc[1](...) }\n"
"        end\n"
"\n"
"        if #result == 1 and type(result[1]) == 'table' then\n"
"            result = result[1]\n"
"        end\n"
"\n"
"        for i, v in pairs(result) do\n"
"            result[i] = db.tuple.new(v)\n"
"        end\n"
"        return result\n"
"    end,\n"
"    eval = function(_db, expr, ...)\n"
"        if type(_db) ~= 'table' then\n"
"            db.error(db.error.PROC_LUA, \"usage: remote:eval(expr, ...)\")\n"
"        end\n"
"        local proc, errmsg = loadstring(expr)\n"
"        if not proc then\n"
"            proc, errmsg = loadstring(\"return \"..expr)\n"
"        end\n"
"        if not proc then\n"
"            db.error(db.error.PROC_LUA, errmsg)\n"
"        end\n"
"        return proc(...)\n"
"    end\n"
"}\n"
"\n"
"setmetatable(remote.self, {\n"
"    __index = function(self, key)\n"
"        if key == 'space' then\n"
"            -- proxy self.space to db.space\n"
"            return require('db').space\n"
"        end\n"
"        return nil\n"
"    end\n"
"})\n"
"\n"
"return remote\n"
""
;
