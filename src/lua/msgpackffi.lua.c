const char msgpackffi_lua[] =
"-- msgpackffi.lua (internal file)\n"
"\n"
"local ffi = require('ffi')\n"
"local builtin = ffi.C\n"
"local msgpack = require('msgpack') -- .NULL, .array_mt, .map_mt, .cfg\n"
"local MAXNESTING = 16\n"
"local int8_ptr_t = ffi.typeof('int8_t *')\n"
"local uint8_ptr_t = ffi.typeof('uint8_t *')\n"
"local uint16_ptr_t = ffi.typeof('uint16_t *')\n"
"local uint32_ptr_t = ffi.typeof('uint32_t *')\n"
"local uint64_ptr_t = ffi.typeof('uint64_t *')\n"
"local float_ptr_t = ffi.typeof('float *')\n"
"local double_ptr_t = ffi.typeof('double *')\n"
"local const_char_ptr_t = ffi.typeof('const char *')\n"
"\n"
"ffi.cdef([[\n"
"uint32_t bswap_u32(uint32_t x);\n"
"uint64_t bswap_u64(uint64_t x);\n"
"]])\n"
"local function bswap_u16(num)\n"
"    return bit.rshift(bit.bswap(tonumber(num)), 16)\n"
"end\n"
"local bswap_u32 = builtin.bswap_u32\n"
"local bswap_u64 = builtin.bswap_u64\n"
"--[[ -- LuaJIT 2.1\n"
"local bswap_u32 = bit.bswap\n"
"local bswap_u64 = bit.bswap\n"
"--]]\n"
"\n"
"--------------------------------------------------------------------------------\n"
"--- Buffer\n"
"--------------------------------------------------------------------------------\n"
"\n"
"local DEFAULT_CAPACITY = 4096;\n"
"\n"
"local tmpbuf = {}\n"
"tmpbuf.s = ffi.new(\"char[?]\", DEFAULT_CAPACITY)\n"
"tmpbuf.e = tmpbuf.s + DEFAULT_CAPACITY\n"
"tmpbuf.p = tmpbuf.s\n"
"tmpbuf.reserve = function(buf, needed)\n"
"    if buf.p + needed <= buf.e then\n"
"        return\n"
"    end\n"
"\n"
"    local size = buf.p - buf.s\n"
"    local capacity = buf.e - buf.s\n"
"    while capacity - size < needed do\n"
"        capacity = 2 * capacity\n"
"    end\n"
"\n"
"    local s = ffi.new(\"char[?]\", capacity)\n"
"    ffi.copy(s, buf.s, size)\n"
"    buf.s = s\n"
"    buf.e = s + capacity\n"
"    buf.p = s + size\n"
"end\n"
"tmpbuf.reset = function(buf)\n"
"    buf.p = buf.s\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"-- Encoder\n"
"--------------------------------------------------------------------------------\n"
"\n"
"local encode_ext_cdata = {}\n"
"\n"
"-- Set trigger that called when encoding cdata\n"
"local function on_encode(ctype_or_udataname, callback)\n"
"    if type(ctype_or_udataname) ~= \"cdata\" or type(callback) ~= \"function\" then\n"
"        error(\"Usage: on_encode(ffi.typeof('mytype'), function(buf, obj)\")\n"
"    end\n"
"    local ctypeid = tonumber(ffi.typeof(ctype_or_udataname))\n"
"    local prev = encode_ext_cdata[ctypeid]\n"
"    encode_ext_cdata[ctypeid] = callback\n"
"    return prev\n"
"end\n"
"\n"
"local function encode_fix(buf, code, num)\n"
"    buf:reserve(1)\n"
"    buf.p[0] = bit.bor(code, tonumber(num))\n"
"    -- buf.p[0] = bit.bor(code, num) -- LuaJIT 2.1\n"
"    buf.p = buf.p + 1\n"
"end\n"
"\n"
"local function encode_u8(buf, code, num)\n"
"    buf:reserve(2)\n"
"    buf.p[0] = code\n"
"    ffi.cast(uint16_ptr_t, buf.p + 1)[0] = num\n"
"    buf.p = buf.p + 2\n"
"end\n"
"\n"
"local function encode_u16(buf, code, num)\n"
"    buf:reserve(3)\n"
"    buf.p[0] = code\n"
"    ffi.cast(uint16_ptr_t, buf.p + 1)[0] = bswap_u16(num)\n"
"    buf.p = buf.p + 3\n"
"end\n"
"\n"
"local function encode_u32(buf, code, num)\n"
"    buf:reserve(5)\n"
"    buf.p[0] = code\n"
"    ffi.cast(uint32_ptr_t, buf.p + 1)[0] = bswap_u32(num)\n"
"    buf.p = buf.p + 5\n"
"end\n"
"\n"
"local function encode_u64(buf, code, num)\n"
"    buf:reserve(9)\n"
"    buf.p[0] = code\n"
"    ffi.cast(uint64_ptr_t, buf.p + 1)[0] = bswap_u64(ffi.cast('uint64_t', num))\n"
"    buf.p = buf.p + 9\n"
"end\n"
"\n"
"local function encode_float(buf, num)\n"
"    buf:reserve(5)\n"
"    buf.p[0] = 0xca;\n"
"    ffi.cast(float_ptr_t, buf.p + 1)[0] = num\n"
"    ffi.cast(uint32_ptr_t, buf.p + 1)[0] = bswap_u32(ffi.cast(uint32_ptr_t, buf.p + 1)[0])\n"
"    buf.p = buf.p + 5\n"
"end\n"
"\n"
"local function encode_double(buf, num)\n"
"    buf:reserve(9)\n"
"    buf.p[0] = 0xcb;\n"
"    ffi.cast(double_ptr_t, buf.p + 1)[0] = num\n"
"    ffi.cast(uint64_ptr_t, buf.p + 1)[0] = bswap_u64(ffi.cast(uint64_ptr_t, buf.p + 1)[0])\n"
"    buf.p = buf.p + 9\n"
"end\n"
"\n"
"local function encode_int(buf, num)\n"
"    if num >= 0 then\n"
"        if num <= 0x7f then\n"
"            encode_fix(buf, 0, num)\n"
"        elseif num <= 0xff then\n"
"            encode_u8(buf, 0xcc, num)\n"
"        elseif num <= 0xffff then\n"
"            encode_u16(buf, 0xcd, num)\n"
"        elseif num <= 0xffffffff then\n"
"            encode_u32(buf, 0xce, num)\n"
"        else\n"
"            encode_u64(buf, 0xcf, 0ULL + num)\n"
"        end\n"
"    else\n"
"        if num >= -0x20 then\n"
"            encode_fix(buf, 0xe0, num)\n"
"        elseif num >= -0x7f then\n"
"            encode_u8(buf, 0xd0, num)\n"
"        elseif num >= -0x7fff then\n"
"            encode_u16(buf, 0xd1, num)\n"
"        elseif num >= -0x7fffffff then\n"
"            encode_u32(buf, 0xd2, num)\n"
"        else\n"
"            encode_u64(buf, 0xd3, 0LL + num)\n"
"        end\n"
"    end\n"
"end\n"
"\n"
"local function encode_str(buf, str)\n"
"    local len = #str\n"
"    buf:reserve(5 + len)\n"
"    if len <= 31 then\n"
"        encode_fix(buf, 0xa0, len)\n"
"    elseif len <= 0xff then\n"
"        encode_u8(buf, 0xd9, len)\n"
"    elseif len <= 0xffff then\n"
"        encode_u16(buf, 0xda, len)\n"
"    else\n"
"        encode_u32(buf, 0xdb, len)\n"
"    end\n"
"    ffi.copy(buf.p, str, len)\n"
"    buf.p = buf.p + len\n"
"end\n"
"\n"
"local function encode_array(buf, size)\n"
"    if size <= 0xf then\n"
"        encode_fix(buf, 0x90, size)\n"
"    elseif size <= 0xffff then\n"
"        encode_u16(buf, 0xdc, size)\n"
"    else\n"
"        encode_u32(buf, 0xdd, size)\n"
"    end\n"
"end\n"
"\n"
"local function encode_map(buf, size)\n"
"    if size <= 0xf then\n"
"        encode_fix(buf, 0x80, size)\n"
"    elseif size <= 0xffff then\n"
"        encode_u16(buf, 0xde, size)\n"
"    else\n"
"        encode_u32(buf, 0xdf, size)\n"
"    end\n"
"end\n"
"\n"
"local function encode_bool(buf, val)\n"
"    encode_fix(buf, 0xc2, val and 1 or 0)\n"
"end\n"
"\n"
"local function encode_bool_cdata(buf, val)\n"
"    encode_fix(buf, 0xc2, val ~= 0 and 1 or 0)\n"
"end\n"
"\n"
"local function encode_nil(buf)\n"
"    buf:reserve(1)\n"
"    buf.p[0] = 0xc0\n"
"    buf.p = buf.p + 1\n"
"end\n"
"\n"
"local function encode_r(buf, obj, level)\n"
"    if type(obj) == \"number\" then\n"
"        -- Lua-way to check that number is an integer\n"
"        if obj % 1 == 0 and obj > -1e63 and obj < 1e64 then\n"
"            encode_int(buf, obj)\n"
"        else\n"
"            encode_double(buf, obj)\n"
"        end\n"
"    elseif type(obj) == \"string\" then\n"
"        encode_str(buf, obj)\n"
"    elseif type(obj) == \"table\" then\n"
"        if level >= MAXNESTING then -- Limit nested tables\n"
"            encode_nil(buf)\n"
"            return\n"
"        end\n"
"        if #obj > 0 then\n"
"            encode_array(buf, #obj)\n"
"            local i\n"
"            for i=1,#obj,1 do\n"
"                encode_r(buf, obj[i], level + 1)\n"
"            end\n"
"        else\n"
"            local size = 0\n"
"            local key, val\n"
"            for key, val in pairs(obj) do -- goodbye, JIT\n"
"                size = size + 1\n"
"            end\n"
"            if size == 0 then\n"
"                encode_array(buf, 0) -- encode empty table as an array\n"
"                return\n"
"            end\n"
"            encode_map(buf, size)\n"
"            for key, val in pairs(obj) do\n"
"                encode_r(buf, key, level + 1)\n"
"                encode_r(buf, val, level + 1)\n"
"            end\n"
"        end\n"
"    elseif obj == nil then\n"
"        encode_nil(buf)\n"
"    elseif type(obj) == \"boolean\" then\n"
"        encode_bool(buf, obj)\n"
"    elseif type(obj) == \"cdata\" then\n"
"        if obj == nil then -- a workaround for nil\n"
"            encode_nil(buf, obj)\n"
"            return\n"
"        end\n"
"        local ctypeid = tonumber(ffi.typeof(obj))\n"
"        local fun = encode_ext_cdata[ctypeid]\n"
"        if fun ~= nil then\n"
"            fun(buf, obj)\n"
"        else\n"
"            error(\"can not encode FFI type: '\"..ffi.typeof(obj)..\"'\")\n"
"        end\n"
"    else\n"
"        error(\"can not encode Lua type: '\"..type(obj)..\"'\")\n"
"    end\n"
"end\n"
"\n"
"local function encode(obj)\n"
"    tmpbuf:reset()\n"
"    encode_r(tmpbuf, obj, 0)\n"
"    return ffi.string(tmpbuf.s, tmpbuf.p - tmpbuf.s)\n"
"end\n"
"\n"
"on_encode(ffi.typeof('uint8_t'), encode_int)\n"
"on_encode(ffi.typeof('uint16_t'), encode_int)\n"
"on_encode(ffi.typeof('uint32_t'), encode_int)\n"
"on_encode(ffi.typeof('uint64_t'), encode_int)\n"
"on_encode(ffi.typeof('int8_t'), encode_int)\n"
"on_encode(ffi.typeof('int16_t'), encode_int)\n"
"on_encode(ffi.typeof('int32_t'), encode_int)\n"
"on_encode(ffi.typeof('int64_t'), encode_int)\n"
"on_encode(ffi.typeof('char'), encode_int)\n"
"on_encode(ffi.typeof('const char'), encode_int)\n"
"on_encode(ffi.typeof('unsigned char'), encode_int)\n"
"on_encode(ffi.typeof('const unsigned char'), encode_int)\n"
"on_encode(ffi.typeof('bool'), encode_bool_cdata)\n"
"on_encode(ffi.typeof('float'), encode_float)\n"
"on_encode(ffi.typeof('double'), encode_double)\n"
"\n"
"--------------------------------------------------------------------------------\n"
"-- Decoder\n"
"--------------------------------------------------------------------------------\n"
"\n"
"local decode_r\n"
"\n"
"local NUMBER_INT_MAX = 4503599627370496LL -- 2^52\n"
"\n"
"local function decode_u8(data)\n"
"    local num = ffi.cast(uint8_ptr_t, data[0])[0]\n"
"    data[0] = data[0] + 1\n"
"    return tonumber(num)\n"
"end\n"
"\n"
"local function decode_u16(data)\n"
"    local num = bswap_u16(ffi.cast(uint16_ptr_t, data[0])[0])\n"
"    data[0] = data[0] + 2\n"
"    return tonumber(num)\n"
"end\n"
"\n"
"local function decode_u32(data)\n"
"    local num = bswap_u32(ffi.cast(uint32_ptr_t, data[0])[0])\n"
"    data[0] = data[0] + 4\n"
"    return tonumber(num)\n"
"end\n"
"\n"
"local function decode_u64(data)\n"
"    local num = bswap_u64(ffi.cast(uint64_ptr_t, data[0])[0])\n"
"    data[0] = data[0] + 8\n"
"    if num < NUMBER_INT_MAX then\n"
"        return tonumber(num) -- return as 'number'\n"
"    end\n"
"    return num -- return as 'cdata'\n"
"end\n"
"\n"
"local function decode_i8(data)\n"
"    local num = ffi.cast(int8_ptr_t, data[0])[0]\n"
"    data[0] = data[0] + 1\n"
"    return tonumber(num)\n"
"end\n"
"\n"
"local function decode_i16(data)\n"
"    local num = bswap_u16(ffi.cast(uint16_ptr_t, data[0])[0])\n"
"    data[0] = data[0] + 2\n"
"     return tonumber(ffi.cast('int16_t', ffi.cast('uint16_t', num)))\n"
"end\n"
"\n"
"local function decode_i32(data)\n"
"    local num = bswap_u32(ffi.cast(uint32_ptr_t, data[0])[0])\n"
"    data[0] = data[0] + 4\n"
"    return tonumber(ffi.cast('int32_t', ffi.cast('uint32_t', num)))\n"
"end\n"
"\n"
"local function decode_i64(data)\n"
"    local num = ffi.cast('int64_t', ffi.cast('uint64_t',\n"
"        bswap_u64(ffi.cast(uint64_ptr_t, data[0])[0])))\n"
"    data[0] = data[0] + 8\n"
"    if num > -NUMBER_INT_MAX and num < NUMBER_INT_MAX then\n"
"        return tonumber(num) -- return as 'number'\n"
"    end\n"
"    return num -- return as 'cdata'\n"
"end\n"
"\n"
"local bswap_buf = ffi.new('char[8]')\n"
"local function decode_float(data)\n"
"    ffi.cast(uint32_ptr_t, bswap_buf)[0] = bswap_u32(ffi.cast(uint32_ptr_t, data[0])[0])\n"
"    local num = ffi.cast(float_ptr_t, bswap_buf)[0]\n"
"    data[0] = data[0] + 4\n"
"    return tonumber(num)\n"
"end\n"
"\n"
"local function decode_double(data)\n"
"    ffi.cast(uint64_ptr_t, bswap_buf)[0] = bswap_u64(ffi.cast(uint64_ptr_t, data[0])[0])\n"
"    local num = ffi.cast(double_ptr_t, bswap_buf)[0]\n"
"    data[0] = data[0] + 8\n"
"    return tonumber(num)\n"
"end\n"
"\n"
"local function decode_str(data, size)\n"
"    local ret = ffi.string(data[0], size)\n"
"    data[0] = data[0] + size\n"
"    return ret\n"
"end\n"
"\n"
"local function decode_array(data, size)\n"
"    assert (type(size) == \"number\")\n"
"    local arr = {}\n"
"    local i\n"
"    for i=1,size,1 do\n"
"        table.insert(arr, decode_r(data))\n"
"    end\n"
"    if not msgpack.cfg.decode_save_metatables then\n"
"        return arr\n"
"    end\n"
"    return setmetatable(arr, msgpack.array_mt)\n"
"end\n"
"\n"
"local function decode_map(data, size)\n"
"    assert (type(size) == \"number\")\n"
"    local map = {}\n"
"    local i\n"
"    for i=1,size,1 do\n"
"        local key = decode_r(data);\n"
"        local val = decode_r(data);\n"
"        map[key] = val\n"
"    end\n"
"    if not msgpack.cfg.decode_save_metatables then\n"
"        return map\n"
"    end\n"
"    return setmetatable(map, msgpack.map_mt)\n"
"end\n"
"\n"
"local decoder_hint = {\n"
"    --[[{{{ MP_BIN]]\n"
"    [0xc4] = function(data) return decode_str(data, decode_u8(data)) end;\n"
"    [0xc5] = function(data) return decode_str(data, decode_u16(data)) end;\n"
"    [0xc6] = function(data) return decode_str(data, decode_u32(data)) end;\n"
"\n"
"    --[[MP_FLOAT, MP_DOUBLE]]\n"
"    [0xca] = decode_float;\n"
"    [0xcb] = decode_double;\n"
"\n"
"    --[[MP_UINT]]\n"
"    [0xcc] = decode_u8;\n"
"    [0xcd] = decode_u16;\n"
"    [0xce] = decode_u32;\n"
"    [0xcf] = decode_u64;\n"
"\n"
"    --[[MP_INT]]\n"
"    [0xd0] = decode_i8;\n"
"    [0xd1] = decode_i16;\n"
"    [0xd2] = decode_i32;\n"
"    [0xd3] = decode_i64;\n"
"\n"
"    --[[MP_STR]]\n"
"    [0xd9] = function(data) return decode_str(data, decode_u8(data)) end;\n"
"    [0xda] = function(data) return decode_str(data, decode_u16(data)) end;\n"
"    [0xdb] = function(data) return decode_str(data, decode_u32(data)) end;\n"
"\n"
"    --[[MP_ARRAY]]\n"
"    [0xdc] = function(data) return decode_array(data, decode_u16(data)) end;\n"
"    [0xdd] = function(data) return decode_array(data, decode_u32(data)) end;\n"
"\n"
"    --[[MP_MAP]]\n"
"    [0xde] = function(data) return decode_map(data, decode_u16(data)) end;\n"
"    [0xdf] = function(data) return decode_map(data, decode_u32(data)) end;\n"
"}\n"
"\n"
"decode_r = function(data)\n"
"    local c = data[0][0]\n"
"    data[0] = data[0] + 1\n"
"    if c <= 0x7f then\n"
"        return tonumber(c) -- fixint\n"
"    elseif c >= 0xa0 and c <= 0xbf then\n"
"        return decode_str(data, bit.band(c, 0x1f)) -- fixstr\n"
"    elseif c >= 0x90 and c <= 0x9f then\n"
"        return decode_array(data, bit.band(c, 0xf)) -- fixarray\n"
"    elseif c >= 0x80 and c <= 0x8f then\n"
"        return decode_map(data, bit.band(c, 0xf)) -- fixmap\n"
"    elseif c >= 0xe0 then\n"
"        return tonumber(ffi.cast('signed char',c)) -- negfixint\n"
"    elseif c == 0xc0 then\n"
"        return msgpack.NULL\n"
"    elseif c == 0xc2 then\n"
"        return false\n"
"    elseif c == 0xc3 then\n"
"        return true\n"
"    else\n"
"        local fun = decoder_hint[c];\n"
"        assert (type(fun) == \"function\")\n"
"        return fun(data)\n"
"    end\n"
"end\n"
"\n"
"---\n"
"-- A temporary const char ** buffer.\n"
"-- All decode_XXX functions accept const char **data as its first argument,\n"
"-- like libmsgpuck does. After decoding data[0] position is changed to the next\n"
"-- element. It is significally faster on LuaJIT to use double pointer than\n"
"-- return result, newpos.\n"
"--\n"
"local bufp = ffi.new('const unsigned char *[1]');\n"
"\n"
"local function check_offset(offset, len)\n"
"    if offset == nil then\n"
"        return 1\n"
"    end\n"
"    local offset = ffi.cast('ptrdiff_t', offset)\n"
"    if offset < 1 or offset > len then\n"
"        error(string.format(\"offset = %d is out of bounds [1..%d]\",\n"
"            tonumber(offset), len))\n"
"    end\n"
"    return offset\n"
"end\n"
"\n"
"-- decode_unchecked(str, offset) -> res, new_offset\n"
"-- decode_unchecked(buf) -> res, new_buf\n"
"local function decode_unchecked(str, offset)\n"
"    if type(str) == \"string\" then\n"
"        offset = check_offset(offset, #str)\n"
"        local buf = ffi.cast(const_char_ptr_t, str)\n"
"        bufp[0] = buf + offset - 1\n"
"        local r = decode_r(bufp)\n"
"        return r, bufp[0] - buf + 1\n"
"    elseif ffi.istype(const_char_ptr_t, str) then\n"
"        bufp[0] = str\n"
"        local r = decode_r(bufp)\n"
"        return r, bufp[0]\n"
"    else\n"
"        error(\"msgpackffi.decode_unchecked(str, offset) -> res, new_offset | \"..\n"
"              \"msgpackffi.decode_unchecked(const char *buf) -> res, new_buf\")\n"
"    end\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"-- db-specific optimized API\n"
"--------------------------------------------------------------------------------\n"
"\n"
"local function encode_tuple(obj)\n"
"    tmpbuf:reset()\n"
"    if obj == nil then\n"
"        encode_fix(tmpbuf, 0x90, 0)  -- empty array\n"
"    elseif type(obj) == \"table\" then\n"
"        encode_array(tmpbuf, #obj)\n"
"        local i\n"
"        for i=1,#obj,1 do\n"
"            encode_r(tmpbuf, obj[i], 1)\n"
"        end\n"
"    else\n"
"        encode_fix(tmpbuf, 0x90, 1)  -- array of one element\n"
"        encode_r(tmpbuf, obj, 1)\n"
"    end\n"
"    return tmpbuf.s, tmpbuf.p\n"
"end\n"
"\n"
"--------------------------------------------------------------------------------\n"
"-- exports\n"
"--------------------------------------------------------------------------------\n"
"\n"
"return {\n"
"    NULL = msgpack.NULL;\n"
"    array_mt = msgpack.array_mt;\n"
"    map_mt = msgpack.map_mt;\n"
"    encode = encode;\n"
"    on_encode = on_encode;\n"
"    decode_unchecked = decode_unchecked;\n"
"    decode = decode_unchecked; -- just for tests\n"
"    encode_tuple = encode_tuple;\n"
"}\n"
""
;
