const char crypto_shorthash_lua[] =
"local ffi = require \"ffi\"\n"
"local lib = ffi.load \"sodium\"\n"
"\n"
"ffi.cdef [[\n"
"size_t crypto_shorthash_siphash24_bytes(void);\n"
"const char * crypto_shorthash_siphash24_primitive(void);\n"
"int crypto_shorthash_siphash24(unsigned char *,const unsigned char *,unsigned long long,const unsigned char *);\n"
"size_t crypto_shorthash_bytes(void);\n"
"size_t crypto_shorthash_keybytes(void);\n"
"const char *crypto_shorthash_primitive(void);\n"
"int crypto_shorthash(unsigned char *out, const unsigned char *in,\n"
"                     unsigned long long inlen, const unsigned char *k);\n"
"]]\n"
"\n"
"local _M = { }\n"
"\n"
"_M.bytes = function() return tonumber(lib.crypto_shorthash_bytes()) end\n"
"_M.keybytes = function() return tonumber(lib.crypto_shorthash_keybytes()) end\n"
"_M.primitive = function() return ffi.string(lib.crypto_shorthash_primitive()) end\n"
"_M.shorthash = function(out, inbuf, inlen, k)\n"
"\tout = out or ffi.new(\"unsigned char[?]\", _M.bytes())\n"
"\tinlen = inlen or #inbuf\n"
"\tassert(lib.crypto_shorthash(out, inbuf, inlen, k) == 0, \"crypto_shorthash returned non-zero\")\n"
"\treturn out\n"
"end\n"
"\n"
"return setmetatable ( _M , { __call = function(_M, ...) return _M.shorthash(...) end } )\n"
"\n"
""
;
