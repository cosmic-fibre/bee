const char crypto_box_lua[] =
"local ffi = require \"ffi\"\n"
"local lib = ffi.load \"sodium\"\n"
"\n"
"ffi.cdef [[\n"
"size_t crypto_box_curve25519xsalsa20poly1305_publickeybytes(void);\n"
"size_t crypto_box_curve25519xsalsa20poly1305_secretkeybytes(void);\n"
"size_t crypto_box_curve25519xsalsa20poly1305_beforenmbytes(void);\n"
"size_t crypto_box_curve25519xsalsa20poly1305_noncebytes(void);\n"
"size_t crypto_box_curve25519xsalsa20poly1305_zerobytes(void);\n"
"size_t crypto_box_curve25519xsalsa20poly1305_boxzerobytes(void);\n"
"size_t crypto_box_curve25519xsalsa20poly1305_macbytes(void);\n"
"const char * crypto_box_curve25519xsalsa20poly1305_primitive(void);\n"
"int crypto_box_curve25519xsalsa20poly1305(unsigned char *,const unsigned char *,unsigned long long,const unsigned char *,const unsigned char *,const unsigned char *);\n"
"int crypto_box_curve25519xsalsa20poly1305_open(unsigned char *,const unsigned char *,unsigned long long,const unsigned char *,const unsigned char *,const unsigned char *);\n"
"int crypto_box_curve25519xsalsa20poly1305_keypair(unsigned char *,unsigned char *);\n"
"int crypto_box_curve25519xsalsa20poly1305_beforenm(unsigned char *,const unsigned char *,const unsigned char *);\n"
"int crypto_box_curve25519xsalsa20poly1305_afternm(unsigned char *,const unsigned char *,unsigned long long,const unsigned char *,const unsigned char *);\n"
"int crypto_box_curve25519xsalsa20poly1305_open_afternm(unsigned char *,const unsigned char *,unsigned long long,const unsigned char *,const unsigned char *);\n"
"size_t crypto_box_publickeybytes(void);\n"
"size_t crypto_box_secretkeybytes(void);\n"
"size_t crypto_box_beforenmbytes(void);\n"
"size_t crypto_box_noncebytes(void);\n"
"size_t crypto_box_zerobytes(void);\n"
"size_t crypto_box_boxzerobytes(void);\n"
"size_t crypto_box_macbytes(void);\n"
"const char *crypto_box_primitive(void);\n"
"int crypto_box_keypair(unsigned char *pk, unsigned char *sk);\n"
"int crypto_box_beforenm(unsigned char *k, const unsigned char *pk,\n"
"                        const unsigned char *sk);\n"
"int crypto_box_afternm(unsigned char *c, const unsigned char *m,\n"
"                       unsigned long long mlen, const unsigned char *n,\n"
"                       const unsigned char *k);\n"
"int crypto_box_open_afternm(unsigned char *m, const unsigned char *c,\n"
"                            unsigned long long clen, const unsigned char *n,\n"
"                            const unsigned char *k);\n"
"int crypto_box(unsigned char *c, const unsigned char *m,\n"
"               unsigned long long mlen, const unsigned char *n,\n"
"               const unsigned char *pk, const unsigned char *sk);\n"
"int crypto_box_open(unsigned char *m, const unsigned char *c,\n"
"                    unsigned long long clen, const unsigned char *n,\n"
"                    const unsigned char *pk, const unsigned char *sk);\n"
"]]\n"
"\n"
"local _M = { }\n"
"\n"
"_M.publickeybytes = function() return tonumber(lib.crypto_box_publickeybytes()) end\n"
"_M.secretkeybytes = function() return tonumber(lib.crypto_box_secretkeybytes()) end\n"
"_M.beforenmbytes = function() return tonumber(lib.crypto_box_beforenmbytes()) end\n"
"_M.noncebytes = function() return tonumber(lib.crypto_box_noncebytes()) end\n"
"_M.zerobytes = function() return tonumber(lib.crypto_box_zerobytes()) end\n"
"_M.boxzerobytes = function() return tonumber(lib.crypto_box_boxzerobytes()) end\n"
"_M.macbytes = function() return tonumber(lib.crypto_box_macbytes()) end\n"
"_M.primitive = function() return ffi.string(lib.crypto_box_primitive()) end\n"
"_M.keypair = function(pk, sk)\n"
"\tpk = pk or ffi.new(\"unsigned char[?]\", _M.publickeybytes())\n"
"\tsk = sk or ffi.new(\"unsigned char[?]\", _M.secretkeybytes())\n"
"\tassert(lib.crypto_box_keypair(pk, sk) == 0, \"crypto_box_keypair returned non-zero\")\n"
"\treturn pk, sk\n"
"end\n"
"_M.beforenm = function(k,pk,sk)\n"
"\tk = k or ffi.new(\"unsigned char[?]\", _M.beforenmbytes())\n"
"\tassert(lib.crypto_box_beforenm(k,pk,sk) == 0, \"crypto_beforenm returned non-zero\")\n"
"\treturn k\n"
"end\n"
"_M.afternm = function(c,m,mlen,n,k)\n"
"\tmlen = mlen or #m\n"
"\tc = c or ffi.new(\"unsigned char[?]\", mlen)\n"
"\tassert(lib.crypto_box_afternm(c,m,mlen,n,k) == 0, \"crypto_afternm returned non-zero\")\n"
"\treturn c\n"
"end\n"
"_M.open_afternm = function(m,c,clen,n,k)\n"
"\tclen = clen or #c\n"
"\tm = m or ffi.new(\"unsigned char[?]\", clen)\n"
"\tassert(lib.crypto_box_open_afternm(m,c,clen,n,k) == 0, \"crypto_open_afternm returned non-zero\")\n"
"\treturn m\n"
"end\n"
"_M.box = function(c,m,mlen,n,pk,sk)\n"
"\tmlen = mlen or #m\n"
"\tc = c or ffi.new(\"unsigned char[?]\", mlen)\n"
"\tassert(lib.crypto_box(c,m,mlen,n,pk,sk) == 0, \"crypto_box returned non-zero\")\n"
"\treturn c\n"
"end\n"
"_M.open = function(m,c,clen,n,pk,sk)\n"
"\tclen = clen or #c\n"
"\tm = m or ffi.new(\"unsigned char[?]\", clen)\n"
"\tassert(lib.crypto_box_open(m,c,clen,n,pk,sk) == 0, \"crypto_box_open returned non-zero\")\n"
"\treturn m\n"
"end\n"
"\n"
"return setmetatable ( _M , { __call = function(_M, ...) return _M.box(...) end } )\n"
""
;
