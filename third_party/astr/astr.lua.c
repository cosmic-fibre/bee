const char astr_lua[] =
"\n"
"\n"
"local _ = {}\n"
"local string = string\n"
"local pairs,ipairs = pairs, ipairs\n"
"local min, floor = math.min, math.floor\n"
"local type = type\n"
"local t_concat = table.concat\n"
"local t_insert = table.insert\n"
"local tonumber, tostring = tonumber, tostring\n"
"local getfenv, rawget = getfenv, rawget\n"
"\n"
"local luaKwords = {\n"
"  ['and'] = true,     ['break'] = true,   ['do'] = true,\n"
"  ['else'] = true,    ['elseif'] = true,  ['end'] = true ,\n"
"  ['false'] = true,   ['for'] = true,     ['function'] = true,\n"
"  ['if'] = true,      ['in'] = true,      ['local'] = true ,\n"
"  ['nil'] = true,     ['not'] = true ,    ['or'] = true,\n"
"  ['repeat'] = true,  ['return'] = true,  ['then'] = true ,\n"
"  ['true'] = true ,   ['until'] = true ,  ['while'] = true,\n"
"}\n"
"\n"
"local luaTypes = {\n"
"  ['nil'] = true,       ['boolean'] = true,\n"
"  ['number'] = true,    ['thread'] = true,\n"
"  ['userdata'] = true,  ['table'] = true,\n"
"  ['string'] = true,    ['function'] = true,\n"
"}\n"
"\n"
"local luaTokens = {\n"
"  ['+'] = true,   ['-']= true,    ['*'] = true,   ['/'] = true,\n"
"  ['%'] = true,   ['=='] = true,  ['~='] = true,  ['<='] = true,\n"
"  ['>='] = true,  ['<'] = true,   ['>'] = true,   ['^'] = true,\n"
"  ['#'] = true,   ['='] = true,   ['('] = true,   [')'] = true,\n"
"  ['{'] = true,   ['}'] = true,   ['['] = true,   [']'] = true,\n"
"  [';'] = true,   [':'] = true,   ['.'] = true,   ['..'] = true,\n"
"  ['...'] = true,\n"
"}\n"
"\n"
"\n"
"------------------------------------------------------------------\n"
"-- Arithmetic metamethods/Indexing features for strings\n"
"------------------------------------------------------------------\n"
"\n"
"local mtstr = getmetatable('')\n"
"function mtstr.__add(a,b) return a .. b end\n"
"function mtstr.__mul(a,b) return type(a) == 'string' and a:rep(b) or b:rep(a) end\n"
"function mtstr.__pow(a,b) return a:rep(b) end\n"
"function mtstr.__div(a,b) return _.chop(a,b) end\n"
"function mtstr.__unm(a) return a:reverse() end\n"
"function mtstr.__mod(a,b)\n"
"  local _chopped = _.chop(a,b)\n"
"  return ((#a)%b==0) and nil or _chopped[#_chopped]\n"
"end\n"
"\n"
"local old_mtIndex = mtstr.__index\n"
"function mtstr.__index(str,i)\n"
"  if type(i)=='number' then\n"
"    local char = str:sub(i,i)\n"
"    return (char and char~='') and char or nil\n"
"  elseif type(old_mtIndex) == 'table' then return old_mtIndex[i]\n"
"  else return old_mtIndex(str,i)\n"
"  end\n"
"end\n"
"\n"
"function mtstr.__call(str,i,j)\n"
"  local i = i or 1\n"
"  local j = j or i\n"
"  if type(i) == 'number' then\n"
"    if type(j) == 'number' then\n"
"      return str:sub(i,j)\n"
"    elseif type(j) == 'string' then\n"
"      return str:sub(1,i-1)..j:sub(1,1)..str:sub(i+1)\n"
"    end\n"
"  end\n"
"end\n"
"\n"
"------------------------------------------------------------------\n"
"-- Private Helpers\n"
"------------------------------------------------------------------\n"
"\n"
"-- Creates a zero-matrix\n"
"local function matrix(row,col)\n"
"  local m = {}\n"
"  for i = 1,row do m[i] = {}\n"
"    for j = 1,col do m[i][j] = 0 end\n"
"  end\n"
"  return m\n"
"end\n"
"\n"
"-- Returns the minimum of a collection of numbers\n"
"local function minOf(...)\n"
"  local _arg = {...}\n"
"  local m = _arg[1]\n"
"  for k,v in ipairs(_arg) do m = min(m,v) end\n"
"  return m\n"
"end\n"
"\n"
"-- Retuns the precedent/next character in Ascii table\n"
"local function preOrSucc(char,dir)\n"
"  return string.char(char:byte()+dir)\n"
"end\n"
"\n"
"-- Returns a list of functions keys packed into an object\n"
"local function functions(obj)\n"
"  local funcs = {}\n"
"  for k,v in pairs(obj) do\n"
"    if type(v) == 'function' then t_insert(funcs,k) end\n"
"  end\n"
"  return funcs\n"
"end\n"
"\n"
"-- Returns the index of value v in table t\n"
"local function findValue(t,v)\n"
"  for k,_v in pairs(t) do\n"
"    if (_v==v) then return k end\n"
"  end\n"
"  return nil\n"
"end\n"
"\n"
"------------------------------------------------------------------\n"
"-- Library functions\n"
"------------------------------------------------------------------\n"
"\n"
"--- Capitalizes the first character of a given string.\n"
"-- <br/><em>Aliased as `capFirst`</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn string a string\n"
"function _.capitalizeFirst(str)\n"
"  return (str:gsub('^%l', string.upper))\n"
"end\n"
"\n"
"--- Capitalizes each word in a given string.\n"
"-- <br/><em>Aliased as `capEach` and `caps`</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn string a string\n"
"-- @see _.capEach\n"
"-- @see _.caps\n"
"function _.capitalizesEach(str)\n"
"  return (str:gsub(\"(%w[%w]*)\",\n"
"      function (match) return _.capitalizeFirst(match) end))\n"
"end\n"
"\n"
"--- Capitalizes substring i to j in a given string\n"
"-- <br/><em>Aliased as `cap`.</em>.\n"
"-- @tparam string str a string\n"
"-- @tparam int i the starting index. Defaults to 1 if not given. Can be negative (counting from right to left)\n"
"-- @tparam int j the ending index. Defaults to the string length if not given.\n"
"-- @treturn string a substring of the given string\n"
"-- @see _.cap\n"
"function _.capitalize(str,i,j)\n"
"  local i,j = i,j\n"
"  if not i then i,j = 1,#str end\n"
"  return (str:gsub(str:sub(i,j),str:sub(i,j):upper()))\n"
"end\n"
"\n"
"--- Lowers the first character in a given string\n"
"-- @tparam string str a string\n"
"-- @treturn string a string\n"
"function _.lowerFirst(str) return (str:gsub('^%u', string.lower)) end\n"
"\n"
"--- Lowers substring i to j in a given string\n"
"-- @tparam string str a string\n"
"-- @tparam int i the starting index. Defaults to 1 if not given. Can be negative (counting from right to left)\n"
"-- @tparam int j the ending index. Default to string length if not given.\n"
"-- @treturn string a string\n"
"function _.lower(str,i,j)\n"
"  local i,j = i,j\n"
"  if not i then i,j = 1,#str end\n"
"  local pat = str:sub(i,j)\n"
"  return (str:gsub(pat,pat:lower()))\n"
"end\n"
"\n"
"--- Tests if a given string contains only upper-case characters.\n"
"-- <br/><em>Aliased as `isLower`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn bool a boolean\n"
"-- @see _.isLower\n"
"function _.isLowerCase(str) return not str:find('%u') end\n"
"\n"
"--- Tests if a given string contains only lower-case characters.\n"
"-- <br/><em>Aliased as `isUpper`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn bool a boolean\n"
"-- @see _.isUpper\n"
"function _.isUpperCase(str) return not str:find('%l') end\n"
"\n"
"--- Tests if a given string starts with a lower-case character\n"
"-- <br/><em>Aliased as `startsLower`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn boolean a boolean\n"
"-- @see _.startsLower\n"
"function _.startsLowerCase(str) return _.isLowerCase(str:sub(1,1)) end\n"
"\n"
"--- Tests if a given string starts with an upper-case character\n"
"-- <br/><em>Aliased as `startsUpper`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn boolean a boolean\n"
"-- @see _.startsUpper\n"
"function _.startsUpperCase(str) return _.isUpperCase(str:sub(1,1)) end\n"
"\n"
"--- Swaps the case of each characters in substring i to j inside a given string\n"
"-- @tparam string str a string\n"
"-- @tparam int i the starting index. Defaults to 1 if not given. Can be negative (counting from right to left)\n"
"-- @param int j the ending index. Default to string length if not given\n"
"-- @treturn string a string\n"
"function _.swapCase(str,i,j)\n"
"  local i,j = i,j\n"
"  if not i then i,j = 1,#str end\n"
"  local oldPat = str:sub(i,j)\n"
"  local _sub = _.chars(oldPat)\n"
"  if _sub then\n"
"    for i,char in ipairs(_sub) do\n"
"      _sub[i] = _.isUpperCase(char) and char:lower() or char:upper()\n"
"    end\n"
"    return (str:gsub(oldPat, t_concat(_sub)))\n"
"  end\n"
"  return str\n"
"end\n"
"\n"
"--- Returns the <em>Levenshtein distance</em> between two strings.\n"
"-- See <a href=\"http://en.wikipedia.org/wiki/Levenshtein_distance\" id=\"Levenshtein Distance on Wikipedia\">Levenshtein Distance on Wikipedia</a>\n"
"-- @tparam strng strA a string\n"
"-- @tparam string strB another string\n"
"-- @treturn int an integer representing the distance between the two given strings\n"
"function _.levenshtein (strA,strB)\n"
"\tif not strB then return 0 end\n"
"  local M = matrix(#strA+1,#strB+1)\n"
"  local i,j,cost\n"
"  local row,col = #M,#M[1]\n"
"  for i = 1,row do M[i][1] = i-1 end\n"
"  for j = 1,col do M[1][j] = j-1 end\n"
"  for i = 2,row do\n"
"    for j = 2,col do\n"
"      if (strA:sub(i-1,i-1) == strB:sub(j-1,j-1)) then cost = 0\n"
"      else cost = 1\n"
"      end\n"
"    M[i][j] = minOf(M[i-1][j]+1,M[i][j-1]+1,M[i-1][j-1]+cost)\n"
"    end\n"
"  end\n"
"  return M[row][col]\n"
"end\n"
"\n"
"--- Converts a string to an array of n characters\n"
"-- <br/><em>Aliased as `split`.</em>.\n"
"-- @tparam string str a string\n"
"-- @tparam int n an integer. Defaults to 1 if not given.\n"
"-- @treturn array an array of strings, each one having a length of n characters at least.\n"
"-- @see _.chars\n"
"function _.chop(str,n)\n"
"  n = n or 1\n"
"  if not (#str > 0) then return nil end\n"
"  local _chopped = {}\n"
"    for w in str:gmatch(('.'):rep(n)) do t_insert(_chopped,w) end\n"
"  local s,e\n"
"  if _chopped and (#_chopped > 0) then\n"
"    s,e = str:find(_chopped[#_chopped])\n"
"    if e then\n"
"    local _end = str:sub(e+1)\n"
"      if _end~='' then t_insert(_chopped,_end) end\n"
"    end\n"
"  elseif #str<=n then _chopped = {str}\n"
"  end\n"
"  return _chopped\n"
"end\n"
"\n"
"--- Clears all special characters or characters matching a given pattern inside a given string\n"
"-- <br/><em>Aliased as `trim`.</em>.\n"
"-- @tparam string str a string\n"
"-- @tparam string pat a pattern matching string to be cleaned from the original string. If not given, will clean non-alphanumeric characters.\n"
"-- @treturn string a string\n"
"-- @see _.trim\n"
"function _.clean(str,pat) return (str:gsub(pat or '%W','')) end\n"
"\n"
"--- Escapes any magic character in agiven string\n"
"-- <br/><em>Aliased as `esc`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn string a string\n"
"-- @see _.esc\n"
"function _.escape(str) return (str:gsub('[%^%$%(%)%%%.%[%]%*%+%-%?]','%%%1')) end\n"
"\n"
"--- Substitutes any sequence matching ${var} or $var with a given value\n"
"-- <br/><em>Aliased as `subst` and `interpolate`.</em>.\n"
"-- @tparam string str a string\n"
"-- @tparam value var a value to be used to replace ${var} or $var occurences\n"
"-- @treturn string a string\n"
"-- @see _.subst\n"
"-- @see _.interpolate\n"
"function _.substitute(str,value) return (str:gsub('%${*([%w]+)}*',value)) end\n"
"\n"
"--- Tests if a given substring is included in a given string\n"
"-- @tparam string str a string\n"
"-- @tparam string sub a substring\n"
"-- @treturn boolean a boolean\n"
"function _.includes(str,sub) return (str:find(sub)) and true or false end\n"
"\n"
"--- Converts a given string to an array of chars\n"
"-- <br/><em>Aliased as `explode`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn array an array of chars\n"
"-- @see _.explode\n"
"function _.chars(str)\n"
"  local _chars = {}\n"
"  for char in str:gmatch('.') do t_insert(_chars,char) end\n"
"  return #_chars>0 and _chars or nil\n"
"end\n"
"_.explode = _.chars\n"
"\n"
"--- Checks if a given string contains only alphabetic characters\n"
"-- @tparam string str a string\n"
"-- @treturn boolean a boolean\n"
"function _.isAlpha(str)  return not str:find('%A') end\n"
"\n"
"--- Checks if a given string contains only digits.\n"
"-- <br/><em>Aliased as `isNum`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn boolean a boolean\n"
"-- @see isNum\n"
"function _.isNumeric(str) return tonumber(str) and true or false end\n"
"\n"
"--- Indexes a string like an array, returning a character. \n"
"-- <br/><em>Aliased as `charAt`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn int i an index\n"
"-- @see _.charAt\n"
"function _.index(str,i)\n"
"  i = i < 0 and #str+i+1 or i\n"
"  return str[i]\n"
"end\n"
"\n"
"--- Checks if a given string matches an email address syntax.\n"
"-- Not compliant with any RFC standards though.\n"
"-- @tparam string str a string\n"
"-- @treturn boolean a boolean\n"
"function _.isEmail(str)\n"
"\treturn (str:match(\"[A-Za-z0-9%.%%%+%-%_]+@[A-Za-z0-9%.%%%+%-%_]+%.%w%w%w?%w?\")~=nil)\n"
"end\n"
"\n"
"--- Returns the number of substring occurences in a given string\n"
"-- @tparam string str a string\n"
"-- @tparam string sub a substring or a pattern matching string\n"
"-- @treturn int the expected count\n"
"function _.count(str,sub) return select(2,str:gsub(sub,sub)) end\n"
"\n"
"--- Inserts a given substring at index position in a given string\n"
"-- @tparam string str a string\n"
"-- @tparam string substring the substring to be inserted\n"
"-- @tparam[opt] int index the insert position, defaults to the end of the string when not given\n"
"-- @treturn string a string\n"
"function _.insert(str,substring,index)\n"
"  index = index > #str and #str+1 or (index < 1 and 1 or index)\n"
"  return str:sub(1,index-1) + (substring) + str:sub(index)\n"
"end\n"
"\n"
"--- Tests if a given string contain any alphanumeric character\n"
"-- @treturn boolean a boolean\n"
"function _.isBlank(str) return (_.count(str,'%w')==0) end\n"
"\n"
"--- Returns a string composed of a concatenation of all given arguments, separated with a given separator\n"
"-- @tparam string sep a string separator\n"
"-- @tparam var_arg ... a list of strings to be concatenated\n"
"-- @treturn string a string\n"
"function _.join(sep,...) return t_concat({...},sep) end\n"
"\n"
"--- Splits a given string in an array on the basis of end-lines characters (`\\n` and/or `\\r`).\n"
"-- @tparam string str a string\n"
"-- @treturn array an array of string\n"
"function _.lines(str)\n"
"  local _lines = {}\n"
"  for l in str:gmatch('[^\\n\\r]+') do t_insert(_lines,l) end\n"
"  if #_lines==0 then return nil end\n"
"  return #_lines == 1 and _lines[1] or _lines\n"
"end\n"
"\n"
"--- Replaces `howMany` characters after index position in a given string with a given substring\n"
"-- @tparam string str a string\n"
"-- @tparam int index an index position in the string\n"
"-- @tparam int howMany the number of characters to be removed after index.\n"
"-- @tparam string substring the substring that will replace the removed sequence.\n"
"-- @treturn string a string\n"
"function _.splice(str,index,howMany,substring)\n"
"  local _str = _.insert(str,substring,index+1)\n"
"  local index = index + (#substring)\n"
"  return _str:sub(1,index) + _str:sub(index + howMany + 1)\n"
"end\n"
"\n"
"--- Tests if a given string starts with a given pattern\n"
"-- @tparam string str a string\n"
"-- @tparam string starts a pattern or a string\n"
"-- @treturn boolean a boolean\n"
"function _.startsWith(str,starts)\n"
"  return (str:find('^'..starts)) and true or false\n"
"end\n"
"\n"
"--- Tests if a given string ends with a given pattern\n"
"-- @tparam string str a string\n"
"-- @tparam string ends a pattern or a string\n"
"-- @treturn boolean a boolean\n"
"function _.endsWith(str,ends)\n"
"  return (str:find(ends..'$')) and true or false\n"
"end\n"
"\n"
"--- Returns the successor of a given character. In case the input was a string of characters, \n"
"-- returns a new string where each character is the successor of the character at the same position in the passed-in string\n"
"-- @tparam string str a string\n"
"-- @tparam int n the n-th successor of a character in the Ascii set\n"
"-- @treturn string a string\n"
"function _.succ(str,n)\n"
"  return (str:gsub('.',\n"
"        function(match) return preOrSucc(match,n or 1) end))\n"
"end\n"
"\n"
"--- Returns the predecessor of a given character. In case the input was a string of characters, \n"
"-- returns a new string where each character is the predecessor of the character at the same position in the passed-in string\n"
"-- @tparam string str a string\n"
"-- @tparam int n the n-th predecessor of a character in the Ascii set\n"
"-- @treturn string a string\n"
"function _.pre(str,n)\n"
"  return (str:gsub('.',\n"
"        function(match) return preOrSucc(match,n and -n or -1) end))\n"
"end\n"
"\n"
"--- Title-izes a given string (each word beginning with a capitalized letter)\n"
"-- @tparam string str a string\n"
"-- @treturn string a string\n"
"function _.titleize(str)\n"
"  return (str:gsub('(%w[%w]*)',_.capitalizeFirst))\n"
"end\n"
"\n"
"--- Converts a given string (underscored or dasherized) into camelized style\n"
"-- @tparam string str a string\n"
"-- @treturn string a string\n"
"function _.camelize(str)\n"
"  return (str:find('[_-]')\n"
"     and _.clean(_.titleize(str:gsub('[_-]',' ')),'%s')\n"
"      or _.clean(str,'%s'))\n"
"end\n"
"\n"
"--- Converts a given string (camelized or dasherized) into underscored style\n"
"-- @tparam string str a string\n"
"-- @treturn string a string\n"
"function _.underscored(str)\n"
"  if #str < 2 then return str end\n"
"  local str = str:sub(1,1):lower()..str:sub(2)\n"
"  str = str:gsub('(%u)', function(match) return '_' + match:lower() end)\n"
"           :gsub('[%s]+([^%s])', function(match) return '_' + match:lower() end)\n"
"  return (str:gsub('-','_'):gsub('^_',''):gsub('_[_]+','_'))\n"
"end\n"
"\n"
"--- Converts a given string (unerscored or camelized) into dasherized style\n"
"-- @tparam string str a string\n"
"-- @treturn string a string\n"
"function _.dasherize(str)\n"
"  return (str:gsub('(%s*_%s*)','-')\n"
"             :gsub('(^%s*-%s*)','')\n"
"             :gsub('(%s*-+%s*)','-')\n"
"             :gsub('(%s*%u%s*)',function(match) return '-' + match:gsub('%s',''):lower() end)\n"
"             :gsub('(%s+)','-')\n"
"             :gsub('%-+$',''))\n"
"end\n"
"\n"
"--- Converts a given string (underscored, humanized, dasherized or camelized) into a human-readable form\n"
"-- @tparam string str a string\n"
"-- @treturn string a string\n"
"function _.humanize(str)\n"
"  str = str:gsub('[_-]',' ')\n"
"           :gsub('%s$','')\n"
"           :gsub('%s%s+','')\n"
"           :gsub('^%s','')\n"
"  str = str:sub(1,1) .. str:sub(2):gsub('(%u)', function(match) return ' ' .. match:lower() end)\n"
"  return (_.capitalizeFirst(str:lower():gsub('%s*_*id$','')))\n"
"end\n"
"\n"
"--- Formats a given number to a string\n"
"-- @tparam number num a number.\n"
"-- @tparam[opt] int decimals the number of decimals after the whole part. Defaults to 0 when omitted.\n"
"-- @tparam[optchain] string thousandSeparator the symbol used to separate thousands. Defaults to `,` when not given.\n"
"-- @tparam[optchain] string decimalSeparator the symbol used to separate the whole part from the decimal part. Defaults to `.` when not given.\n"
"-- @tparam[optchain] string sign the string to be used to replace the minus symbol for negative numbers. Defaults to `-` when omitted.\n"
"-- @treturn string a string\n"
"function _.numberFormat(num, decimals, thousandSeparator, decimalSeparator, sign)\n"
"\tnum = (floor(num)==num and (tostring(num)..'.0') or tostring(num))\n"
"\tlocal int, dec = num:match('(-*%d+)%.(%d*)')\n"
"  local fmt, repl_pattern, repl = int, \"%1\"..(thousandSeparator or ',')..\"%2\" \n"
"  while true do\n"
"\t\tfmt, repl = fmt:gsub(\"^(-?%d+)(%d%d%d)\", repl_pattern)\n"
"    if (repl==0) then break end\n"
"  end\n"
"\tfmt = sign and (fmt:gsub('^%-',sign)) or fmt\n"
"\tdecimals = decimals or 0\n"
"\tif decimals <= 0 then return fmt end\n"
"\tif #dec > decimals then\n"
"\t\tdec = tonumber(dec:sub(decimals+1,decimals+1))>5 \n"
"\t\t  and tostring(tonumber(dec:sub(1,decimals))+1)\n"
"\t\t\t or dec:sub(1,decimals)\n"
"\telse\n"
"\t\tdec = _.rpad(dec,decimals,'0')\n"
"\tend\n"
"\treturn (('%s%s%s'):format(fmt,(decimalSeparator or '.'),dec))\n"
"end\n"
"\n"
"--- Converts a given string into an array of words\n"
"-- @tparam string str a string\n"
"-- @treturn array an array of string\n"
"function _.words(str)\n"
"  local _words = {}\n"
"  for word in str:gmatch('%w+') do t_insert(_words,word) end\n"
"  return #_words>0 and _words or nil\n"
"end\n"
"\n"
"--- Pads a given string with characters\n"
"-- @tparam string str a string\n"
"-- @tparam int length the final string length\n"
"-- @tparam string padStr the padding string character\n"
"-- @tparam string side the padding direction. Should be either 'left' (see @{lpad}), 'right' (see @{rpad}) or 'both' (see @{lrpad}).\n"
"-- @treturn string a string\n"
"function _.pad(str,length,padStr,side)\n"
"  local str = str\n"
"  local padStr = padStr:sub(1,1)\n"
"  local side = side or 'left'\n"
"  if side == 'left' then return (padStr:rep(length - str:len()) .. str)\n"
"  elseif side == 'right' then return str..(padStr:rep(length - str:len()))\n"
"  elseif side == 'both' then\n"
"    local side = 'left'\n"
"      while str:len() < length do\n"
"      str = _.pad(str,str:len() + 1,padStr,side)\n"
"      side = (side =='left' and 'right' or 'left')\n"
"      end\n"
"    return str\n"
"  end\n"
"end\n"
"\n"
"--- Left-pads a given string\n"
"-- <br/><em>Aliased as `rjust`.</em>.\n"
"-- @tparam string str a string\n"
"-- @tparam int length the final string length\n"
"-- @tparam string padStr the padding string character\n"
"-- @treturn string a string\n"
"function _.lpad(str,length,padStr) return _.pad(str,length,padStr,'left') end\n"
"\n"
"--- Right-pads a given string\n"
"-- <br/><em>Aliased as `ljust`.</em>.\n"
"-- @tparam string str a string\n"
"-- @tparam int length the final string length\n"
"-- @tparam string padStr the padding string character\n"
"-- @treturn string a string\n"
"function _.rpad(str,length,padStr) return _.pad(str,length,padStr,'right') end\n"
"\n"
"--- Left and right padding for strings.\n"
"-- <br/><em>Aliased as `center`.</em>.\n"
"-- @tparam string str a string\n"
"-- @tparam int length the final string length\n"
"-- @tparam string padStr the padding string character\n"
"-- @treturn string a string\n"
"function _.lrpad(str,length,padStr) return _.pad(str,length,padStr,'both') end\n"
"\n"
"--- Returns the substring after the first pattern occurence in a given string\n"
"-- @tparam string str a string\n"
"-- @tparam string pattern a pattern-matching string\n"
"-- @treturn string a string\n"
"function _.strRight(str,pattern)\n"
"  local s,e = str:find(pattern)\n"
"  local ret\n"
"  if e then\n"
"    ret =  str:sub(e+1)\n"
"    return ret~='' and ret or nil\n"
"  end\n"
"  return nil\n"
"end\n"
"\n"
"--- Returns the substring after the last pattern occurence in a given string\n"
"-- @tparam string str a string\n"
"-- @tparam string pattern a pattern-matching string\n"
"-- @treturn string a string\n"
"function _.strRightBack(str,pattern)\n"
"  local _str,s,e,ret\n"
"  for i = -1,-(#str),-1 do\n"
"    _str = str:sub(i)\n"
"    s,e = _str:find(pattern)\n"
"    if e then\n"
"      ret = _str:sub(e+1)\n"
"      return ret~='' and ret or nil\n"
"    end\n"
"  end\n"
"  return nil\n"
"end\n"
"\n"
"--- Returns the substring before the first pattern occurence in a given string\n"
"-- @tparam string str a string\n"
"-- @tparam string pattern a pattern-matching string\n"
"-- @treturn string a string\n"
"function _.strLeft(str,pattern)\n"
"  local s,e = str:find(pattern)\n"
"  local ret\n"
"  if s then\n"
"    ret = str:sub(1,s-1)\n"
"    return ret~='' and ret or nil\n"
"    end\n"
"  return nil\n"
"end\n"
"\n"
"--- Returns the substring before the last pattern occurence in a given string\n"
"-- @tparam string str a string\n"
"-- @tparam string pattern a pattern-matching string\n"
"-- @treturn string a string\n"
"function _.strLeftBack(str,pattern)\n"
"  local _str,s,e,ret\n"
"  for i = -1,-(#str),-1 do\n"
"    _str = str:sub(i)\n"
"    s,e = _str:find(pattern)\n"
"    if s then\n"
"      ret = str:sub(1,#str+i)\n"
"      return ret~='' and ret or nil\n"
"    end\n"
"  end\n"
"  return nil\n"
"end\n"
"\n"
"--- Converts an array of strings into a human-readable string\n"
"-- @tparam array an array of values\n"
"-- @tparam[opt] string delimiter a delimiter. Defaults to comma character when not given.\n"
"-- @tparam[optchain] string lastDelimiter the last delimiter to be used. Defaults to ` and ` when not given.\n"
"-- @treturn string a string\n"
"function _.toSentence(array,delimiter, lastDelimiter)\n"
"  local delimiter = delimiter or ','\n"
"  local lastDelimiter = lastDelimiter or ' and '\n"
"  local j = #array\n"
"  for i,entry in ipairs(array) do\n"
"    if i>1 and i<j then\n"
"      array[i] = entry:gsub('^%w',function(match) return ' ' + match end)\n"
"    end\n"
"  end\n"
"  return _.capitalizeFirst(t_concat(array,delimiter,1,j-1) + lastDelimiter + array[j]) .. '.'\n"
"end\n"
"\n"
"--- Repeats a given string concatenated with a given separator count times.\n"
"-- @tparam string str a string\n"
"-- @tparam[opt] int count the repetitions count. Defaults to 2 when not given.\n"
"-- @tparam[optchain] string sep a separator. Defaults to space character when not given.\n"
"-- @treturn string a string\n"
"function _.rep(str,count,sep) return (str .. (sep or ' ')):rep(count or 2) end\n"
"\n"
"--- Wraps a given string\n"
"-- @tparam string str a string\n"
"-- @treturn string a wrapped string\n"
"function _.surround(str,wrap) return wrap .. str .. wrap end\n"
"\n"
"--- Returns a quoted string\n"
"-- @tparam string str a string\n"
"-- @treturn string a quoted string\n"
"function _.quote(str) return ('%q'):format(str) end\n"
"\n"
"--- Returns an array of Ascii codes for a given set of characters\n"
"-- @tparam string str a string\n"
"-- @treturn array an array of ascii codes\n"
"function _.bytes(str)\n"
"  local _byteSet = {}\n"
"  for char in str:gmatch('.') do\n"
"    if not _byteSet[char] then _byteSet[char] = char:byte() end\n"
"  end\n"
"  return _byteSet\n"
"end\n"
"\n"
"--- Returns the Ascii code of the i-th character in the given string\n"
"-- @tparam string str a string\n"
"-- @tparam int i an index\n"
"-- @treturn int a number representing the Ascii code of the i-th char\n"
"function _.byteAt(str,i) return (str[i]):byte() end\n"
"\n"
"--- Checks if the given string is a Lua reserved keyword.\n"
"-- <br/><em>Aliased as `isLuaKword` and `isReserved`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn boolean a boolean\n"
"-- @see _.isLuaKword\n"
"-- @see _.isReserved\n"
"function _.isLuaKeyword(str) return luaKwords[str] and true or false end\n"
"\n"
"--- Tests if a given substring is a known Lua token (operator).\n"
"-- <br/><em>Aliased as `isOperator` and `isOp`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn boolean a boolean\n"
"-- @see _.isToken\n"
"-- @see _.isOperator\n"
"function _.isToken(str) return luaTokens[str] and true or false end\n"
"\n"
"--- Tests if a given substring is a valid Lua identifier for a variable\n"
"-- <br/><em>Aliased as `isIden` and `isVarName`.</em>.\n"
"-- @tparam string str a string\n"
"-- @treturn boolean a boolean\n"
"-- @see _.isIden\n"
"-- @see _.isVarName\n"
"function _.isIdentifier(str)\n"
"    return (str:match('^[%a_]+[%w_]*$') and not _.isReserved(str)) and true or false\n"
"end\n"
"\n"
"--- Checks if the given input is has a known Lua type or matches an expected type.\n"
"-- @tparam value var some variable\n"
"-- @tparam string expectedType an expected type for the passed-in variable. If not given, the function will check if the actual variable type is known to Lua.\n"
"-- @treturn boolean a boolean\n"
"function _.is(var,expectedType)\n"
"  local _varType = type(var)\n"
"  if expectedType then return (_varType == expectedType) end\n"
"  return luaTypes[_varType] and _varType or nil\n"
"end\n"
"\n"
"--- Returns a table listing counts for each match to a given pattern\n"
"-- <br/><em>Aliased as `stats`.</em>.\n"
"-- @tparam string str a string\n"
"-- @tparam string pat a pattern matching string\n"
"-- @treturn array an array\n"
"-- @see _.stats\n"
"function _.statistics(str,pat)\n"
"  local pat = pat or '.'\n"
"  local _rep = {}\n"
"  for w in (string.gmatch(str,pat,pat)) do\n"
"    _rep[w] = (_rep[w] or 0) + 1\n"
"  end\n"
"  return _rep\n"
"end\n"
"\n"
"--- Imports library functions inside a given context or the global environment.\n"
"-- @tparam[opt] table context a context. Defaults to `_G` (global environment) when not given.\n"
"-- @tparam[optchain] boolean noConflict Skips function import in case its key already exists in the given context\n"
"-- @treturn table the passed-in context\n"
"function _.import(context, noConflict)\n"
"\tcontext = context or _G\n"
"\tfor k,v in pairs(_) do\n"
"\t\tif rawget(context,k) then\n"
"\t\t\tif not noConflict then context[k] = v end\n"
"\t\telse \n"
"\t\t\tcontext[k] = v\n"
"\t\tend\t\t\n"
"\tend\n"
"\treturn context\n"
"end\n"
"\t\n"
"if rawget(_G, 'ASTR_ALIASES') then\n"
"\t_.capFirst = _.capitalizeFirst\n"
"\t_.capEach = _.capitalizesEach\n"
"\t_.caps = _.capitalizesEach\n"
"\t_.cap = _.capitalize\n"
"\t_.isLower = _.isLowerCase\n"
"\t_.isUpper = _.isUpperCase\n"
"\t_.startsLower = _.startsLowerCase\n"
"\t_.startsUpper = _.startsUpperCase\n"
"\t_.split = _.chop\n"
"\t_.trim = _.clean\n"
"\t_.esc = _.escape\n"
"\t_.subst = _.substitute\n"
"\t_.interpolate = _.substitute\n"
"\t_.isNum = _.isNumeric\n"
"\t_.charAt = _.index\n"
"\t_.next = _.succ\n"
"\t_.numFmt = _.numberFormat\n"
"\t_.rjust = _.lpad\n"
"\t_.ljust = _.rpad\n"
"\t_.center = _.lrpad\n"
"\t_.isLuaKword = _.isLuaKeyword\n"
"\t_.isReserved = _.isLuaKeyword\n"
"\t_.isOperator = _.isToken\n"
"\t_.isOp = _.isToken\n"
"\t_.isIden = _.isIdentifier\n"
"\t_.isVarName = _.isIdentifier\n"
"\t_.stats = _.statistics\n"
"end\n"
"\n"
"return _\n"
""
;
